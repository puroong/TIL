# 파일처리

## 파일처리는 왜 필요할까?
- 주기억장치에 비해 보조기억장치의 읽기/쓰기 속도기 너무 느리기 때문이다
- 디스크는 메모리보다 적은 비용으로 훨씬 더 많은 용량을 제공한다
## 파일이란?
- 같은 레코드들의 집합이면 CD, 하드디스크, 자기테이프와 같은 보조기억장치에 저장된다
## 파일 구조란?
- 파일의 데이터들을 표현하거나 그 데이터에 접근하는 연산들을 관리하는 것의 결합이다
## 좋은 파일 구조의 목표는?
- 최소한의 비용으로 데이터를 가져오는 것
    - 디스크를 접근한 횟수가 비용을 
## 파일 구조의 역사
### Sequential access
- 레코드들을 순서대로 접근함
### Simple Index
- 인덱스 파일과 데이터 파일을 분리하고, 인덱스 파일에 키와 포인터를 저장함. 
    이때 포인터는 데이터 파일의 위치로 이 값을 통해 데이터 파일에 접근함
### Binary tree
- 이진 트리
- 하지만 노드가 불균형하게 삽입될 시 성능이 나쁘다
### AVL Tree
- 이진 트리를 개선한 것
- AVL Tree는 왼쪽의 깊이와 오른쪼의 깊이의 차가 1보다 작거나 같아야함.
    노드가 없는 경우 깊이를 0으로 봄
### Balanced Tree
- 이진트리는 노드가 2개인 대신 깊이가 높아서 탐색에 시간이 많이 걸림
    Balanced Tree는 노드가 2개 이상일 수 있는 대신 깊이를 줄임으로서 탐색 시간을 개선함

## 물리적 파일과 논리적 파일
### 물리적 파일
- 보조기억장치에 실제로 존재하는 파일로, os가 인식하고 있는 파일이며, 파일 디렉토리로 볼 수 있음
### 논리적 파일
- 프로그램이 설정한 논리적 파일로, 실제 파일이 어디에 있던 프로그램이 파일을 효율적으로 연산하기 위해서 존재함
## 하드디스크
### 구성요소1
- 모터, 플래터, 암(arm), 헤드, 스핀들... 
#### 특징
- 플래터는 데이터를 저장하는 항목으로 하드디스크 내에 여러개 존재함
- 하드 디스크에 데이터를 읽거나 쓰기 위해서 플래터을 돌려야하는데 이를 위해 모터가 있음
- 하드 디스크에서 데이터를 읽거나 쓸 때 암(arm)과 헤드를 사용한다.
    암(arm) 끝 부분에 헤드가 있는데 읽거나 쓰고 싶은 위치에 헤드를 놓아야한다.
    헤드를 원하는 위치에 놓기 위해선 플래터를 돌리면 된다.
### 구성요소2
- 트랙(가로)
- 섹터
- 실린더(새로): 플래터 개수와 같음
- 갭
### 하드 디스크의 용량을 계산하는 방법
- bytes per sector * sectors per track * tracks per cylinder * cynlinder
### 구성요소3
- 섹터
    - 디스크에 접근하기 위한 가장 작은 단위
        섹터들이 모여서 트랙을 이룹니다
- 클러스터
    - 연속된 섹터로 구성돼있습니다
    - 파일 할당의 가장 작은 기본 단위입니다
- Extent
    - 연속된 클러스터들입니다
### 디스크 접근 비용
- 디스크 접근 비용 = seek time + rotational time + transfer time    
    - seek time = cylinkder 1/3만큼 이동할 때의 비용을 평균값으로 사용한다
    (헤드 위치를 사용자가 원하는 데이터가 존재하는 실린더로 이동시키는 작업)
    - rotational delay = 보통 반바퀴를 돌 때의 비용을 평균값으로 쓴다
    (데이터를 헤드 바로 아래로 이동시키기 위해 플래터를 회전시키는 작업에 걸리는 시간)
    - transfer time = (number of bytes transferred) / (number of bytes on a track) * (rotation time)
    (헤드를 실린더랑 접촉한 상태에서 데이터 크기만큼 회전을 시키면 헤드가 데이터를 읽는 작업에 걸리는 시간)

        * sequential access와 random access로 디스크 접근 비용 구하는 문제 여러번 복습