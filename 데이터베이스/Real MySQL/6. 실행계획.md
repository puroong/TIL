# 실행 계획

## 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다

첫 번째 단계를 SQL 파싱이라하며, SQL파서로 SQL 파스트리를 만든다

두 번째 단계는 파스 트리를 참자하여 아래와 같은 내용을 처리한다
* 불필요한 조건의 제거 및 복잡한 연산의 단순화
* 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
* 각 테이블에 사용된 조인과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
* 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

두 번째 단계를 최적화 및 실행계획 수립 단계라 하며 MySQL 서버의 옵티마이저가 처리한다

세 번재 단계는 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고, MySQL엔진에서는 스토리지 엔진ㅇ로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다

첫 번째, 두 번째 단계는 MySQL 엔진이 처리하고 세번째는 MySQL엔진과 스토리지 엔진이 동시에 참여해서 처리한다

## 옵티마이저의 종류

옵티마이저는 두 방법 중 하나를 사용한다
* 비용 기반 최적화 방법
    * 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 각 실행 계획별 비용을 산출한다

* 규칙 기반 최적화 방법
    * 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식이다
        통계정보(테이블 레코드 건수나 칼럼 값의 분포도)를 고려하지 않고 실행 계획이 수립되기 때문에 거의 항상 같은 실행 방법을 만들어낸다
        하지만 이미 오래 전부터 많은 DBMS에서 거의 지원되지 않거나 업데이트되지 않은 상태로 그대로 남아있다
    
규칙 기반 최적화 방법은 각 테이블이나 인덱스의 통계 정보가 거의 없고, 상대적으로 느린 CPU 연산 탓에 비용 계산 과정이 부담스러웠기 때문에 사용되던 최적화 방법이다
현재는 거의 대부분의 RDBMS가 비용 기반의 옵티마이저를 채택하고 있으며, MySQL 역시 마찬가지다

## 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보다
통계정보가 정확하지 않다면 엉뚱한 방향으로 쿼리를 실행해 버릴 수 있기 때문이다

예를 들어 1억 건의 레코드가 저장된 테이블의 통계 정보가 갱신되지 않아서 레코드가 10건 미만인 것처럼 되어 있다면 옵티마이저는 실제 쿼리 실행 시에 인텍스 레인지 스캔이 아니라
테이블을 처음부터 끝까지 앍는 방식(풀 테이블 스캔)으로 실행해 버릴 수도 있다

기본적으로 MySQL에서 관리되는 통계 정보는 대략의 레코드 건수와 인덱스의 유니크한 값의 개수 정도가 전부다
(다른 DBmS에 비해 다양한 편은 아니다)

MySQL에서 통계 정보는 사용자가 알아채지 못하는 순간순간 자동으로 변경되기 떄문에 상당히 동적인 편이다
하지만 레코드 건수가 많지 않으면 통계 정보가 상당히 부정확한 경우가 많으므로 ANALYZE 명령을 이용해 강제적으로 통계 정보를 갱신해야 할 때도 있다 
이런 현상은 레코드 건수가 얼마 되지 않는 개발용 MySQL서버에서 자주 발생한다 

MyiSAM과 InnoDB의 테이블과 인덱스 통계 정보는 다음과 같이 확인할 수 있다
```
SHOW TABLE STATUS LIKE 'user'\G;
SHOW INDEX FROM user;
```

통계 정보를 갱신하려면 다음과 같이 ANALYZE를 실행하면 된다
```
// 파티션을 사용하지 않는 일반 테이블의 통계 정보 수집
ANAYLZE TABLE user;

// 파티션을 사용하는 테이블에서 특정 파티션의 통계 정보 수집
ALTER TABLE user ANALYZE PARTITION p3;
```

MyISAM은 ANAYLZE를 실행하는 동안 읽기만 가능하다
InnoDB는 둘 다 불가능하므로 서비스 도중에는 ANALYZE를 실행하지 않는 것이 좋다

MyISAM은 정확한 키값 분포도를 위해 인덱스 전체를 스캔하므로 많은 시간이 소요된다
이와는 달리 InnoDB 테이블은 인덱스 페이지 중에서 8개 정도만 랜덤하게 선택해서 분석하고 그 결과를 인덱스의 통계 정보롤 갱신하다

> MySQL 5.138 미만 버전에선 항상 랜덤하게 인덱스 페이지 8개만 읽어서 통계 정보를 수집하지만
> 그 이상의 InnoDB 플러그인 버전에선 분석할 인덱스 페이지 개수를 innodb_stats_sample_pages 파라미터로 지정할 수 있다
> 분석할 페이지 개수를 늘릴수록 더 정확한 통계 정보를 수집할 수 있겠지만 InnoDB의 통계정보는 다른 DBMS보다 훨씬 자주 수집되며 서비스 도중에도
> 통계 정보가 수집될 수 있다
> InnoDB의 통계 수집을 위한 인덱스 페이지 개수는 기본값 8개에서 2~3배 이상을 벗어나지 않도록 설정하는 것이 좋다

## 실행계획 분석

MySQL에서 쿼리의 실행 계획을 확인하려면 EXPLAIN 명령을 사용하면 된다

EXPLAIN 키워드 뒤에 확인하고 싶은 SELECT 쿼리 문자을 적으면 된다

EXPLAIN의 출력 결과는 쿼리 문장에서 사용된 테이블의 개수만큼 출력된다
(서브 쿼리로 임시테이블을 생성한 경우 그 임시 테이블까지 포함)

**실행 순서**는 위에서 아래로 순서대로 표시된다

MySQL에서는 필요에 따라 실행 계획을 산출하기 위해 쿼리의 일부분을 직접 실행할 때도 있다

때문에 쿼리 자체가 상당히 복잡하고 무거운 쿼리인 경우에는 실행 계획의 조회 또한 느려질 수 있다

INSERT, UPDATE, DELETE에 대한 쿼리 실행 계획은 확인할 수 없다

이를 확인하기 위해선 WHERE 조건절만 같은 SELECT문으로 변환하여 대략적으로 확인할 수 있다

### id 칼럼

하나의 SELECT 문장은 다시 1개 이상의 서브 SELECT 문장을 포함할 수 있다

예를 들어 아래의 쿼리 문장에 있는 각 SELECT를 다음과 같이 분리해서 생각할 수 있다

```
SELECT ...
FROM (SELECT ... FROm user) u,
    study s
WHERE u .id = s.id
```

```
SELECT ... FROM user;
SELECT ... FROM u, study s WHERE u .id = s.id;
```

실행 계획에서 가장 왼쪽에 표시되는 id칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다

만약 하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id가 부여된다

### select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다

* SIMPLE
    * UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우

* PRIMARY
    * UNION이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리

* UNION
    * UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리
    * UNION의 첫 번째 단위 SELECT는 UNION 쿼리로 결합된 전체 집합의 select_type이 표시된다
    * 아래 쿼리에선 세 개의 서브 쿼리로 조회된 결과를 UNION ALL로 결합해 임시 테이블을 만들어서 사용하고 있으므로 DEREIVED라는 select_type을 갖는다

    ```
    EXPLAIN
    SELECT * FROM (
        (SELECT emp_no FROM employees e1 LIMIT 10)
        UNION ALL
        (SELECT emp_no FROM employees e2 LIMIT 10)
        UNION ALL
        (SELECT emp_no FROM employees e3 LIMIT 10)
    ) tb;
    ```

* DEPENDENT UNION
    * UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시된다
    * 여기서 DEPENDENT는 UNION이나 UNION ALL로 결합된 단일 쿼리가 외부의 영향을 받는 것을 의미한다
    * 내부 쿼리가 외부의 값을 참조해서 처리될 때 DEPENDENT 키워드가 포함된다

    ```
    EXPLAIN
    SELECT
        e.first_name,
        (SELECt CONCAT('Salary chage count : ', COUNT(*)) AS message
            FROM salaries s WHERE s.emp_no=e.emp_no
        UNION
        SELECT CONCAT('Department change count : '), COUNT(*) AS message
            FROM dept_emp de WHERE de.emp_no=e.emp_no
        ) as message
    FROM employees e
    WHERE e.emp_no=10001;
    ```

```
하나의 단위 SELECT 쿼리가 다른 단위 SELECT를 포함하고 있으면 이를 서브 쿼리라고 표현한다
이처럼 서브 쿼리가 사용된 경우에는 외부 쿼리보다 서브쿼리가 먼저 실행되는 것이 일반적이며, 대부분이 이 방식이 그 반대의 경우보다 빠르게 처리된다
하지만 select_type에 DEPENDENT 키워드를 포함하는 서브 쿼리는 외부 쿼리에 의존적이므로 절대 외부 쿼리보다 먼저 실행될 수가 없다
그래서 select_type에 DEPENDENT 키워드가 포함되는 쿼리는 비효율적인 경우가 많다
```

* UNION RESULT
    * UNION 결과를 담아두는 테이블
    * UNION, UNION ALL 쿼리는 모두 UNION 결과를 임시 테이블로 생성하는데 이 테이블의 select_type이다

* SUBQUERY
    * FROM 절 이외에서 사용되는 서브 쿼리
    * FROM 절에 사용된 서브 쿼리는 DERIVED로 표시되고 그 이외의 서브 쿼리는 SUBQUERY로 표시된다

```
서브 쿼리는 사용되는 위치에 따라 각각 다른 이름을 지니고 있다

* 중첩된 쿼리 (nested query)
    SELECT 되는 칼럼에 사용된 서브 쿼리
* 서브 쿼리
    WHERE 절에 사용된 서브 쿼리
* 파생 테이블
    FROM 절에 사용된 서브 쿼리

서브 쿼리가 반환하는 값의 특성에 따라 다음과 같이 구별하기도 한다

* 스칼라 서브 쿼리
    하나의 값(칼럼이 단 하나인 레코드 하나)만 반환하는 쿼리
* 로우 서브 쿼리
    칼럼의 개수에 관계 없이 하나의 레코드만 반환하는 쿼리
```

* DEPENDENT SUBQUERY
    * 서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우
    
    ```
    EXPLAIN
    SELECT e.first_name,
        (SELECT COUNT(*)
            FROM dept_emp de, dept_manager dm
            WHERE dm.dept_no=de.dept_no AND de.emp_no=e.emp_no) AS cnt
    FROM employees e
    WHERE e.emp_no=10001;
    ```
    
    * 안쪽의 서브 쿼리 결과가 바깥쪽 SELECT 쿼리의 칼러메 의존적이라서 DEPENDENT라는 키워드가 붙음
    * 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 일반 서브 쿼리보다는 처리속도가 느릴 때가 많다

* DERIVED
    * 서브 쿼리가 FROM절에 사용된 경우 MySQL은 항상 select_type이 DERIVED인 실행계획을 만든다
    * 단위 SELECT 쿼리의 실행 결과를 메모리나 디스크에 임시테이블을 생성하는 것을 의미한다
    * MySQL은 파생 테이블을 잘 최적화하지 못하는 경우가 많다
    * 파생 테이블엔 인덱스가 전혀 없기 때문에 다른 테이블과 조인할 때 성능 상 불리할 때가 많다

```
쿼리를 튜닝하기 위해 실행 계획을 확인할 때 가장 먼저 select_type 칼럼의 값이 DERIVED인 것이 있는지 확인해야 한다
다른 방법이 없어서 서브 쿼리를 사용하는 것은 피할 수 없지만 조인으로 해결할 수 있는 경우라면 조인을 쓰는 것이 좋다
```

* UNCACHEABLE SUBQUERY
    * 하나의 쿼리 문장에서 서브 쿼리가 하나만 있더라도 실제 그 쿼리가 한 번만 실행되는 것은 아니다
    * 그런데 조건이 똑같은 서브 쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 서브 쿼리의 결과를 내부적인 캐시 공간에 담아둔다
    * 여기서 언급하는 서브 쿼리 캐스는 파생 테이블과는 전혀 무관한 기능이다

    * SUBQUERY vs DEPENDENT SUBQUERY
        * SUBQUERY는 바깥쪽의 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다
        * DEPENDENT SUBQUERY는 의존하는 바깥쪽 쿼리의 값 단위로 캐시해두고 사용한다
    * SUBQUERY와 달리 DEPENDENT SUBQUERY는 결과가 한 번만 캐시되는 것이 아니라 외부 쿼리의 값 단위로 캐시가 만들어지는 방식으로 처리된다
    
    * 캐시를 사용할 수 없는 경우 select_type이 UNCACHEABLE SUBQUERY다
        * 사용자 변수가 서브 쿼리에 사용된 경우
        * NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브 쿼리 내에 사용된 경우
        * UUID나 RAND 같이 호출할 때마다 달라지는 함수가 서브 쿼리에 있는 경우

    * 예시
    ```
    EXPLAIN
    SELECT *
    FROM employees e
    WHERE e.emp_no = (
        SELECT @status FROM dept_emp de WHERE de.dept_no='d005'
    );
    ```

* UNCACHEABLE UNION

### table 칼럼

* 테이블의 이름에 별칭이 부여된 경우엔 별칭이 표시된다
* 종종 \<derived\>, \<union\>과 같이 <>로 둘러싸인 이름으로 명시되는 경우가 많은데, 이 테이블은 임시 테이블을 의미한다
* 또한 \<\>안에 항상 표시되는 숫자는 단위 SELECT 쿼리의 id를 지칭한다

### type 칼럼

* MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 의미한다
    * 방식이라 함은 인덱스를 사용해 레코드를 읽었는지 아니면 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔으로 읽었는지를 말한다

    * system
        * 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 점근 방법
        * InnoDB에선 사용되지 않고 MyISAM/MEMORY 테이블에서만 사용된다
            (InnoDB에선 ALL또는 index로 표시될 가능성이 크다)
    * const
        * 테이블 레코드 건수에 관계 없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리방식을 const라고 한다
        * 다른 DBMS에선 이를 유니크 인덱스 스캔이라고도 표현한다
        * 프라이머리 키의 일부만 조건으로 사용할 때는 접근 방식이 ref로 표시된다

        ```
        실행계획을 type칼럼이 const인 실행계획은 MySQL의 옵티마이저가 쿼리를 최적화하느 단계에서 모두 상수화한다
        그래서 실행 계획의 type 칼럼의 값이 const라고 표시된다
        ```
    
    * eq_ref
        * 여러 테이블이 조인되는 쿼리의 실행계획에서 표시된다
        * 조인에서 두번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있다
            (두번재 이후에 읽히는 테이블을 유니크 키로 검색할 때 그 유니크 인덱스는 NOT NULL이어야 하며, 다중 칼럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 칼럼이 비교 조건에 사용돼야만 eq_ref접근 방법을 사요할 수 있다)
    
    * ref
        * eq_ref와는 달리 조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키 등의 제약 조건도 없다
        * 인덱스의 종류와 관계없이 동등 조건으로 검색할 대는 ref 접근 방법이 사용된다
        * ref타입은 반환되는 레코드 1건이라는 보장이 없어서 const나 eq_ref보다는 빠르지 않다
        * 하지만 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나다
    
    * fulltext
        * MySQL의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다
        * 전문 검색 인덱스는 통계 정보가 관리되지 않고 전문 검색 인덱스를 사용하려면 전혀 다른 SQL문법을 사용해야 한다
        * 따라서 전문 인덱스를 사용할 수 있는 쿼리에서는 비용과 관계 없이 거의 매번 fulltext접근 방식을 사용한다

        * 전문 검색은 다음과 같이 할 수 있다
        ```
        EXPLAIN
        SELECT *
        FROM employee_name
        WHERE emp_no=10001
            AND emp_no BETWEEN 10001 AND 10005  
        AND MATCH(first_name, last_name) AGAINST('Facello' IN BOOLEAN MODE);
        ```
    
    * ref_or_null
        * ref와 접근 방식은 같은데 null 비교가 추가된 형태다
    
    * unique_subquery
        * WHER 조건절에서 사용될 수 있는 IN 형태의 쿼리를 위한 접근 방식이다
        * 서브쿼리에서 중복되지 않은 유니크한 값만 반환할 때 이 접근 방법을 사용한다
    
    * index_subquery
        * IN 연산자는 IN 또는 IN 형태의 조건은 괄호안에 있는 값의 목록에서 중복된 값이 먼저 제거돼야 한다
        * unique_subquery는 중복된 값을 만들지 않는다는 보장이 있지만 index_subquery는 그렇지 않다
        * 서브쿼리가 중복된 값을 반환할 수 있지만 중복된 값을 인덱스를 이용해 제거할 수 있을 때 index_subquery 접근 방법이 이용된다
    
    * range
        * 인덱스 레인지 스캔 형태의 접근 방법이다
        * 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미한다
        * 주로 \<, \>, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때 사용된다

    * index_merge
        * 2개 이상의 인덳스를 이용해 각각의 검색 결과를 만들어낸 후 그 결과를 병합하는 처리 방식이다
        * 아래와 같은 특징을 가지고 있다
            * 여러 인덱스를 읽어야 하므로 range 접근 방식 보다 효율성이 떨어진다
            * AND와 OR 연산이 복잡하게 연결된 쿼리에서는 제대로 최적화되지 못할 때가 많다
            * 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않는다
            * index_merge 접근 방식으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 또는 중복 제거와 같은 부가적인 작업이 더 필요하다
    
    * index
        * 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다
        * range 접근 방식과 같이 효울적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것은 아니다
        * index 접근 방식은 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같다
        * 하지만 인덱스는 일반적으로 데이터 파일 전체보다는 크기가 작아서 풀 테이블 스캔보다는 효율적이므로 더 빠르게 처리된다
        * 아래 조건 가눙데 (첫 번째 + 두번째) 조건을 충적하거나 (첫번째 + 세번째) 조건을 충족하는 쿼리에서 사용된다
            * range나 const 또는 ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우
            * 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우(즉, 에티터 파일을 읽지 않아도 되는 경우)
            * 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우(즉, 별도의 정렬 작업을 피할 수 없는 경우)
    
    * all
        * 풀 테이블 스캔을 의미하는 접근 방식이다
        * 다른 DBMS처럼 InnoDB도 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 디스크 IO를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어들이는 기능을 제공한다
        * 이를 리드 어헤드라고 하며 한 번에 여러 페이지를 읽어서 처리할 수 있다
        * 데이터웨어하우스나 배치 프로그램처럼 대용량의 레코드를 처리하는 쿼리에서는 잘못 튜닝된 쿼리보다 더 나은 접근 방법이 되기도 한다
        * 쿼리를 튜닝한다는 것이 무조건 인덱스 풀 스캔이나 테이블 풀 스캔을 사용하지 못하게 하는 것은 아니라는 점을 기억하자

        * 일반적으로 index와 ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응담을 사용자에게 보여줘야 하는 웹 서비스 등과 같은 OLTP 환경에선 적합하지 않다
        
        ```
        MySQL에서는 연속적으로 인접한 페이지가 연속해서 몇 번 읽히게 되면 백그라운드로 작동하는 읽기 스레드가 최대 한 번에 64개의 페이지씩 한꺼번에 디스크로부터 읽어들이기 때문에 한 번에 페이지 하나씩 읽어들이는 작업보다는 상당히 빠르게 레코드를 읽을 수 있다
        이러한 작동 방식을 리드 어헤드라고 한다
        ```

### possible_keys

* MySQL 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방식에서 사용되는 인덱스의 목록이다
* **사용될 법 했던 인덱스**의 목록이므로 거의 모든 인덱스가 목록에 나온다
* 따라서 쿼리를 튜닝할 때 아무런 도움이 되지 않는다

### key

* 최종 선택된 실행 계획에서 사용되는 인덱스를 의미한다
* 쿼리를 튜닝할 땐 key 칼럼에 의도한 인덱스가 표시되는지 확인해야 한다
* key 칼럼에 표시되는 값이 PRIMARY라면 PK가 사용된다는 의미이고, 그 이외의 값은 모두 테이블이나 인덱스를 생성할 때 부여했던 고유 이름이다

* 실행 계획 타입이 index_merge가 아닌 경우, 반드시 테이블 하나당 하나의 인덱스만 이용할 수 잇다
* 하지만 index_merge 실행 계획이 사용될 때는 2개 이상의 인덱스가 사용되는데, 이때는 ,로 구분되어 표시된다

* 그리고 실행 계획의 type이 ALL일 때와 같이 인덱스를 전혀 사용하지 못한다면 key 칼럼은 NULL로 표시된다

### key_len

* 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려준다
* 더 정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다

* char(4) 타입 안덱스를 사용했다면 3*4바이트가 key_len 값이다
* char(4)와 integer 타입 인덱스들을 사용했다면 3*4 + 4가 key_len 값이다
* key_len 값을 표시하는 기준은 MySQL 버전 별로 다르다

--------
```
EXPLAIN
SELECT * FROM dept_emp WHERE dept_no='d005' AND emp_no <> 10001;
```

* MySQL 5.0 이하 버전
    * 쿼리 문장은 프라이머리 키를 구성한 emp_no와 dept_no의 조건을 줘씨만 key_len 값은 12로 바뀌었다.
        그 이유는 key_len에 표시된는 값은 인덱스를 이용해 범위를 제한하는 조건의 칼럼까지만 포함되며
        단순히 체크 조건으로 사용된 칼럼은 key_len에 포함되지 않기 떄문이다
        그래서 MySQL 5.0에서는 key_len 칼럼의 값으로 인덱스의 몇 바이트까지가 범위 제한 조건으로 사용됐는지 판단할 수 있다
    
* MySQL 5.1 이상의 버전
    * key_len이 다시 16으로 표시된다. 또한 type 칼럼 값이 ref에서 range로 바뀌었다
        결과적으로 key_len 칼럼의 값으로 인덱스의 몇 바이트까지가 범위 제한 조건으로 사용됐는지 알 수 없다

* 위 차이는 MySQL 엔진과 InnoDb 스토리지 엔진의 역할 분담에 큰 변화가 생긴 것이 원인이다
* MySQL 5.0까지는 범위 제한 조건으로 사용되는 칼럼만 스토리지 엔진으로 전달했다
* MySQL 5.1부터는 조건이 범위 제한 조건이든 체크 조건이든지 관계없이, 인덱스를 이용할 수만 있다면 모두 스토리지 엔진으로 전달한다
* MySQL에선 이를 컨디션 푸시 다운이라고 한다

### ref

* select_type이 ref인 경우 참조 조건으로 어떤 값이 제공됐는지 보여준다
* 만약 상수 값을 지정했다면 ref 칼럼의 값은 const로 표시되고, 다른 테이블의 칼럼값이면 그 테이블 명과 칼럼 명이 표시된다
* 가끔 쿼리의 실행 계획에서 ref 칼럼의 값이 func라고 표시될 때가 있다
* 이는 Function의 줄임말로 참조용으로 사용되는 값을 그대로 사용한 것이 아니라, 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다

```
EXPLAIN
SELECT *
FROM employees e, dept_emp de
WHERE e, emp_no=de.emp_no;
```

* 이 쿼리는 조인 조건에 사용된 emp_no 칼럼의 값에 대해 아무런 변환이나 가공도 수행하지 않앗다
* 그래서 이 쿼리의 실행 계획은 아래와 같이 ref 칼럼에 조인 대상 칼럼의 이름이 그대로 표시된다

* 쿼리의 조인 조건에 간단한 산술 표현식을 넣어 쿼리를 만들고 실행 계획을 확인해보자

```
EXPLAIN
SELECT *
FROM employees e, dept_emp de
WHERE e.emp_no=(de.emp_no-1);
```

* 위의 쿼리에서는 dept_emp 테이블을 읽어서 de.emp_no 값에서 1을 뺀 값으로 employees 조인하고 있다
* 이 쿼리의 실행 계획에서는 ref 값이 조인 칼럼의 이름이 아니라 func라고 표시되는 것을 확인하고 있다

* 사용자가 명시적으로 값을 변환할 때뿐만 아니라, MySQL 서버가 내부적으로 값을 변환해야 할 때도 ref 칼럼에는 func가 출력된다
* 문자집합이 일치하지 않는 두 문자열 칼럼을 조인한다거나, 숫자 타입의 칼럼과 문자열 타입의 칼럼으로 조인할 때가 대표적인 예다
* 가능하다면 MySQL 서버가 이런 변환을 하지 않아도 되도록 조인 칼럼의 타입은 일치시키는 편이 좋다

### rows

* 옵티마이저는 각 조건에 대해 가능한 처리 방식을 나열하고, 각 처리 방식의 비용을 비교해 최종적으로 하나의 실행 계획을 수립한다
* 이때 비용을 산정하는 방법은 각 처리 방식이 얼마나 많은 레코드를 읽고 비교해야 하는지 예측해 보는 것이다
* 대상 테이블에 얼마나 많은 레코드가 포함돼 있는지 또는 각 인덱스 값의 분포도가 어떤지를 통계 정보를 기준으로 조사해서 예측한다

* 이 칼럼은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다
* 이 값은 각 스토리지 엔진 별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상 값이라서 정확하지는 않다
* 또한 rows 칼럼에 표시되는 값은 반환하는 레코드 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 디스크로부터 읽고 체크해야 하는지를 의미한다
* 그렇기 때문에 쿼리 결과로 반환된 레코드 건수와 일치하지 않는 경우가 많다

* LIMIT이 포함되는 쿼리는 rows 칼럼에 표시되는 값이 오차가 너무 심해서 도움되지 않는다

### Extra

* 쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 표시된다

    * const row not found
        * const 접근 방식으로 테이블을 읽었지만 해당 테이블에 레코드가 1건도 없는 경우이다
    
    * Distinct
    
    * Full scan on NULL key
        * `col1 IN (SELECT col2 FROM ...)`과 같은 조건이 포함된 쿼리에서 자주 발생할 수 있다
        * 만약 col1 값이 NULL이 된다면 `NULL IN (SELECT col2 FROM ...)`과 같이 바뀐다
        * SQL 표준에서 NULL을 알수 없는 값으로 정의하고 있고 아래와 같은 연산 규칙을 정했다
            * 서브 쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 NULL
            * 서브 쿼리가 1건도 결과 레코드를 가지지 않는다면 최종 비교 결과는 FALSE
        * 이 비교 과정에서 col1이 NULL이면 풀 테이블 스캔을 해야만 결과를 알아낼 수 있다
        * Full scan on NULL key는 col1이 NULL일 경우 예비책으로 풀 테이블 스캔을 사용할 것이라는 것을 알려준다
    
    * Impossible HAVING
        * 쿼리에 사용된 HAVING 절의 조건을 만족하는 레코드가 없을 때 실행 계획의 Extra 칼럼에는 Impossible HAVING 키워드가 표시된다
        
        ```
        EXPLAIN
        SELECT e.emp_no, COUNT(*) AS cnt,
        FROM employees e
        WHERE e.emp_no=10001
        GROUP BY e.emp_no
        HAVING e.emp_no IS NULL;
        ```

        * 위 예제에서 HAVING 조건에 `e.emp_no IS NULL`이라는 조건이 추가됐지만 emp_no는 PK이면서 NOT NULL 타입의 칼럼이다
        * 그러므로 결코 e.emp_no IS NULL 조건을 만족할 가능성이 없으므로 Impossible HAVING이라는 키워드를 표시한다
    
    * Impossible WHERE
        * Impossible HAVING과 비슷하며 WHERE 조건이 항상 FALSE가 될 수 밖에 없는 상황에 표시된다

    * Impossible WHERE noticed after reading const tables
        * 다음 쿼리의 경우 실행 계획만 확인하더라도 옵티마이저가 사번이 0인 사원이 없다는 사실을 확인한다
        * 실행 계획을 만드는 과정에서 쿼리의 일부분을 실행해보기 때문이다

        ```
        EXPLAIN
        SElECT * FROM employees WHERE emp_no=0;
        ```

        * 위 쿼리는 employees 테이블의 프라이머리 키를 동등 조건으로 비교하고 있으므로 const 접근 방식을 사용한다
        * const 접근 방식이 필요한 부분은 실행계획 수립단계에서 옵티마이저가 쿼리의 일부를 실행하고 결과를 쿼리의 상수로 대체한다

    * No matching min/max row
        * min/max와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때 표시된다
        * min(), max()의 결과로 NULL이 반환된다
    
    * No matching row in const table
        * 조인에 사용된 테이블에서 const 접근 방식으로 접근할 때, 일치하는 레코드가 없을 때 표시된다
        
    * No tables used
        * FROM 절이 없는 쿼리나 FROM DUAL 형태의 실행 계획에서 표시된다
    
    * Not exists
        * 안티 조인
            * A 테이블엔 있지만 B 테이블에는 없는 값을 조회하는 쿼리
            * not in (subquery) 또는 not exists를 자주 사용
            * 또는 아우터 조인으로도 처리할 수 있다
            * 이러한 형태의 조인을 안티 조인이라함
        
        * 아우터 조인 예시
        ```
        EXPLAIN
        SELECT *
        FROM dept_emp de
            LEFT JOIN departments d ON de.dept_no=d.dept_no
        WHERE d.dept_no IS NULL;
        ```
        * 아우터 조인을 이용한 인티 조인 쿼리에선 Extra 칼럼에 not exists 메시지가 표시된다
        * MySQL이 내부적으로 어떤 최적화를 했는데 그 최적화 이름이 not exists인 것이다
        * 해당 쿼리를 not exists 형태의 쿼리로 변환해서 처리했음을 의미하는 것이 아니다

    * Range checked for each record (index map: N)
        * 조인 조건에 상수가 없고 둘 다 변수인 경우(e1.emp_no, e2.emp_no), 옵티마이저는 e1 테이블을 먼저 읽고 조인을 위해 e2 테이블을 읽을 때, 인덱스 레인지 스캔과 풀 테이블 스캔 중에서 어느 것이 효율적일지 판단할 수 없게 된다.
        * e1 테이블의 레코드를 하나씩 읽을 때마다 e1.emp_no 값이 계속 바뀌므로 쿼리의 비용 계산을 위한 기준값이 계속 변하는 것이다
        
        ```
        EXPLAIN
        SELECT *
        FROM employees e1, employees e2
        WHERE e2.emp_no >= e1.emp_no;
        ```

        * 예를 들어 사번이 1번 1억까지 있다고 가정해 보자
        * 그러면 e1 테이블을 처음부터 끝까지 스캔하면서 e2테이블에서 e2.emp_no > e1.emp_no 조건을 만족하는 레코드를 찾아야 하는데, 문제는 e.emp_no=1인 경우에는 e2 테이블의 1억건을 전부 읽어야 한다는 것이다
        * 하지만 e1.emp_no=100000000인 경우에는 e2테이블을 한 건만 읽으면 된다는 것이다
        * 그래서 e1 테이블의 emp_no가 작을 때는 e2 테이블을 풀 테이블 스캔으로 접근하고, e1 테이블의 emp_no가 큰 값일 때는 e2 테이블을 인덱스 레인지 스캔으로 접근하는 형태를 수행하는 것이 최적의 조인 방법일 것이다
        * 지금까지 설명한 내용으 줄여서 표현하면 `메 레코드마다 인덱스 레인지 스캔을 체크한다`라고 할 수 있다
        
        * Extra 칼럼의 출력 내용 중에서 `(index map: 0x1)`은 사용할지 말지를 판단하는 후보 인덱스의 순번을 나타낸다
        * index map은 16진수로 표시되는데, 이를 해석하려면 우선 이진수로 표현을 바꿔야 한다
        * 위의 실행 계획에서는 0x1이 표시됐는데, 이는 이진수로 바꿔도 1이다
        * 그래서 이쿼리는 e2테이블의 첫번재 인덱스를 사용할지 아니면 풀 테이블을 스캔할지를 매번 판단한다는 것을 의미한다
        * 여기서 테이블의 첫 번째 인덱스란 `SHOW CREATE TABLE employees` 명령으로 테이블의 구조를 조회했을 때 제일 먼저 출력되는 인덱스를 말한다

        * 그리고 쿼리 실행 게획의 type 칼럼의 값이 ALL로 표시되어 풀 테이블 스캔으로 처리된 것으로 해석하기 쉽다
        * 하지만 `Extra chechekd for each record`가 표시되면 type 칼럼에는 ALL로 표시된다
        * 즉 index map에 표시된 후보 인덱스를 사용할지 여부를 검토해서 이 후보 인덱스가 별로 도움이 되지 않는다면 최종적으로 풀 테이블 스캔을 사용하기 때문에 ALL로 표시된 것이다

        * index map에 대한 이해를 돋기 위해 조금 더 복잡한 index map을 예제로 살펴보자
        * 우선 아래와 같이 인덱스가 여러 개인 테이블에 실행되는 쿼리의 실행 계획에서 `(index map: 0x19)`이라고 표시됐다고 가정하자

        ```
        CREATE TABLE tb_member(
            mem_id INTEGER NOT NULL,
            mem_name VARCHAR(100) NOT NULL,
            mem_nickname VARCHAR(100) NOT NULL,
            mem_region TINYINT,
            mem_gender TINYINT,
            mem_phone VARCHAR(25),
            PRIMARY KEY (mem_id),
            INDEX ix_nick_name (mem_nickname, mem_name).
            INDEX ix_nick_region (mem_nickname, mem_region),
            INDEX ix_nick_ gender (mem_nickname, mem_gender),
            INDEX ix_nick_phone (mem_nickname, mem_phone)
        );
        ```

        * 0x19를 이진수로 변환해보면 11001이다
        * 이 값은 비트 플래그로 각 자리수가 인덱스의 순번에 대응된다
        
    * Scanned N databases
        * MySQL 5.0부터 INFORMATION_SCHEMA라는 DB가 제공된다
        * 이 DB는 MySQl 내에 존재하는 DB의 메타 정보 (테이블, 칼럼, 인덱스 등의 스키마 정보)를 모아둔 DB다
        * INFORMATION_SCHEMA 내의 모든 테이블은 읽기 전용이다
        * 이 DB 내의 테이블은 레코드가 있는 것이 아니라 SQL을 이용해 조회할 때마다 메타 정보를 MySQL 서버의 메모리에서 가져와서 보여준다
        
        * MySQL 5.1부턴 INFORMATION_SCHEMA DB를 빠르게 조회할 수 있게 개선됐다
        * 개선된 조회를 통해 메타 정볼를 검색할 경우 쿼리 실행 계획의 Extra 칼럼에 Scanned N databases라는 메시지가 표시된다
        * N은 0, 1, all 중 하나의 값을 가진다
            * 0: 특정 테이블의 정보만 요청되어 데이터베이스 전체의 메타 정보를 읽지 않음
            * 1: 특정 데이터ㅔ이스 내의 모든 스키마 정보가 요처오디어 해당 데이터베이스의 모든 스키마 정보 읽음
            * all: MySQL 서버 내의 모든 스키마 정보 다 읽음
        
        * 아래 쿼리의 경우 employees DB의 employees 테이블 정보만 읽었다
        * 따라서 N은 0이다

        ```
        EXPLAIN
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'employees' AND table_name='employees';
        ```
    
    * Select tables optimized away
        * MIN() 또는 MAX()만 SELECT 절에 사용되거나 GROUP BY로 MIN/MAX를 조회하는 쿼리가 적절한 인덱스를 사용할 수 없을 때 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용된다면 Extra 칼럼에 Select tables optimized away가 표시된다

        * 또한 MyISAM 테이블에 대해서는 GROUP BY 없이 COUNT(*)만 SELECT할 때도 이런 형태의 최적화가 적용된다
        * MyISAM 테이블은 전체 레코드 건수를 별도로 관리하기 때문에 인덱스나 데이터를 읽지 않고도 전체 건수를 빠르게 조회할 수 있다
        * 하지만 WHERE 절에 조건을 가질 때는 이러한 최적화를 사용하지 못한다

        ```
        EXPLAIN
        SELECt MAX(emp_no), MIN(emp_no) FROM employees;

        EXPLAIN
        SELECT MAX(from_date), MIN(from_date) FROM salaries WHERE emp_no=10001;
        ```

    * Skip_open_table, Open_frm_only, Open_trigger_only, Open_full_table
        * Scanned N databases와 마찬가지로 INFORMATION_SCHEMA의 메타 정보를 조회하는 SELECT 쿼리의 실행계획에서만 확인할 수 있다

        * 테이블의 메타 정보가 저장된 파일(.FRM)과 트리거가 저장된 파일(.TRG) 또는 데이터 파일 중에서 필요한 파일만 읽었는지 또는 불가피하게 모든 파일을 다 읽었는지 등의 정보를 보여준다

        * 다음 4가지 중 하나가 표시된다
            * Skip_open_table: 테이블의 메타 정보가 저장된 파일을 별도로 읽을 필요가 없음
            * Open_frm_only: 테이블의 메타 정보가 저장된 파일(.FRM)을 열어서 읽음
            * Open_trigger_only: 트리거 정보가 저장된 파일을 열어서 읽음(.TRG)
            * Open_full_table: 최적화되지 못해서 테이블 메타정보 파일과 데이터(.MYD) 및 인덱스 파일(.MYI)까지 모두 읽음
        
        * 위의 내용에서 데이터(.FRM) 파일이나 인덱스(.MYI)와 관련된 내용은 MyISAM에만 해당되며, InnoDB 스토리지 엔진을 사용하는 테이블에는 적용되지 않는다

    * unique row not found
        * 두 개의 테이블이 각각 유니크 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 표시된다

    * Using filesort
        * ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 사용하지 못할 때는 MySQL 서버가 조회된 레코드를 다시 한 번 정렬해야 한다
        * ORDER BY 처리가 인덱스를 사용하지 못할 때만 실행 계획의 Extra 칼럼에는 Using filesort가 표시된다
        * 이때 조회된 레코드를 정렬용 메모리 버퍼에 복사해 퀵 소트 알고리즘을 수행한다
        * Using filesort가 출려되는 쿼리는 많은 부하를 일으키므로 가능하다면 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다

    * Using index (커버링 인덱스)
        * 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 Extra 칼럼에 Using index가 표시된다
        * 인덱스를 이용해 처리하는 쿼리에서 가장 큰 부하를 차지하는 부분은 인덱스를 검색해 일치하는 레코드의 나머지 칼럼 값을 가져오기 위해 데이터 파일을 찾아서 가져오는 작업이다
        * 최악의 경우에는 인덱스를 통해 검색된 결과 레코드 한 건 한 건마다 디스크를 한 번씩 읽어야 할 수도 있다

        * 인덱스만으로 처리되는 것을 커버링 인덱스라고 한다
        
        * InnoDB의 모든 테이블은 클러스터링 인덱스로 구성되어있다
        * 이 때문에 InnoDB 테이블의 모든 보조 인덱스는 데이터 레코드의 주소 값으로 프라이머리 키값을 가진다
        * InnoDB에선 일부 칼럼만으로 인덱스를 만들어도 결국 그 인덱스에 프라이머리 키가 같이 저장되는 효과를 낸다
        * 이러한 클러스터링 인덱스 특성 때문에 쿼리가 커버링 인덱스로 처리될 가능성이 상당히 높다

        * 레코드 건수에 따라 차이는 있겠지만 쿼리를 커버링 인덱스로 처리할 수 있을 때와 그렇지 못할 때의 성능 차이는 수십 배에서 수백배까지 날 수 있다
        * 하지만 무조건 커버링 인덱스로 처리하려고 인덱스에 많은 칼럼을 추가하면 더 위험한 상황이 초래할 수도 있다
        * 너무 과도하게 인덱스의 칼럼이 많아지면 인덱스의 크기가 커져서 메모리 낭비가 심해지고 레코드를 저장하거나 변경하는 작업이 매우 느려질 수 있기 때문이다

        * 접근방법이 eq_req, ref, range,index_merge, index등과 같이 인덱스를 사용하는 실행 계획에서는 모두 extra 칼럼에 using index가 표시될 수 있다
        * 즉 인덱스 레인짖 스캔 (eq_ref, ref, range ,index_merge)을 사용할 때만 커버링 인덱스로 처리되는 것은 아니다
        * 인덱스를 풀 스캔(index)을 실행할 때도 커버링 처리될 수 있는데 이때도 똑같은 인덱스 풀 스캔의 접근 방법이라면 커버링 인덱스가 아닌 경우보다 훨씬 빠르게 처리된다
    
    * Using index for group-by
        * GROUP BY 처리를 위해 MySQL 서버는 그루핑 기준 칼럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그룹핑하는 형태의 고부하 작업을 필요로 한다
        * 하지만 GROUP BY 처리가 인덱스를 이용하면 정렬된 인덱스 칼럼을 순서대로 읽으면서 그룹핑 작업만 수행한다
        * GROUP BY 처리가 인덱스를 사용할 대 extra 칼럼에 Using index for group by가 표시된다

        * GROUP BY 처리를 위해 인덱스를 읽는 방법을 루스 인덱스 스캔이라고 한다
        * GROUP BY 처리를 위해 단순히 순서대로 쭉 읽는 타이트 인덱스 스캔과는 달리 루스 인덱스 스캔은 인덱스에서 필요한 부분만 듬성 듬성 읽는다
        ---
        * 타이트 인덱스 스캔(인덱스 스캔)을 통한 GROUP BY 처리
            * 인덱스를 사용해서 GROUP BY절을 처리할 수 있더라도 AVG()나 SUM() 또는 COUNT(*)와 같이 조회하려는 값이 모든 인덱스를 다 읽어야 할 때는 필요한 레코드만 듬성듬성 읽을 수 없다
            이런 쿼리는 단순히 GROUP BY를 위해 인덱스를 사용하기는 하지만 이를 루스 인덱스 스캔이라고 하지 않는다
            이런 쿼리의 실행계획에 using index for group by도 표시되지 않는다
        
        ```
        EXPLAIN
        SELECT first_name, COUNT(*) AS counter FROM employees GROUP BY first_name;
        ```

        * 루스 인덱스 스캔을 통한 GROUP BY 처리
            * 단일 칼럼으로 구성된 인덱스에서는 그룹핑 칼럼 말고는 아무것도 조회하지 않는 쿼리에서 루스 인덱스 스캔을 사용할 수 있다
            그리고 다중 칼럼으로 만들어진 인덱스에서는 GROUP BY 절이 인덱스를 사용할 수 있어야 함은 물론이고 MIN()이나 MAX()와 같이 조회하는 값이 인덱스의 첫 번째 또는 마지막 레코드만 읽어도 되는 쿼리는 루스 인덱스 스캔이 사용될 수 있다
            이때는 인덱스를 듬성듬성하게 필요한 부분만 읽는다

        ```
        EXPLAIN
        SELECT emp_no, MIN(from_date) AS first_changed_date, MAX(from_date) AS last_changed_date
        FROM salaries
        GROUP BY emp_no;
        ```

    * GROUP BY에 인덱스를 사용하려면 우선 GROUP BY 조건의 인덱스 사용 요건이 갖춰져야 한다
    * 그리고 WHERE 절에서 사용하는 인덱스에 의해서도 사용 여부가 영향을 받는다
        * WHERE 조건절이 없는 경우
            * 쿼리는 GROUP BY와 조회하는 칼럼이 루스 인덱스 스캔을 사용할 수 있는 조건만 갖추면 된다
            * 그렇지 못한 쿼리는 타이트 인덱스 스캔이나 별도의 정렬 과정을 통해 처리된다
        * WHERE 조건절이 있지만 검색을 위해 인덱스를 사용하지 못한 경우
            * GROUP BY 절은 인덱스를 사용할 수 있지만 WHERE 조건절이 인덱스를 사용하지 못할 때는 먼저 GROUP BY를 위해 인덱스를
            읽은 후, WHERE 조건의 비교를 위해 데이터 레코드를 읽어야만 한다
            그래서 이 경우도 루스 인덱스 스캔을 이용할 수 없으며, 타이트 인덱스 스캔과정을 통해 GROUP BY가 처리된다
            다음의 쿼리는 WHERE절은 인덱스를 사용하지 못하지만 GROUP BY가 인덱스를 사용하는 예제다
        * WHERE절의 조건이 있으며, 검색을 위해 인덱스를 사용하는 경우
            * 하나의 단위 쿼리가 실행되는 경우에 index_merge 이외의 접근 방법에서는 단 하나의 인덱스만 사용할 수 있다
            그래서 WHERE 절의 조건이 인덱스를 사용할 수 있으면 GROUP BY가 인덱스를 사용할 수 있는 조건이 더 까다로워진다
            즉 WHERE 절의 조건이 검색하는 데 사용했던 인덱스를 GROUP BY 처리가 다시 사용할 수 있을 때만 루스 인덱스 스캔을 사용할 수 있다
            만약 WHERE 조건절이 사용할 수 있는 인덱스와 GROUP BY 처리가 사용할 수 있는 인덱스가 다른 경우라면 일반적으로 옵티마이저는 WHERE 조건절이 인덱스를 사용하도록 실행 계획을 수립하는 경향이 있다
            때로는 전혀 작업 범위를 좁히지 못하는 WHERE 조건이라 하더라도 GROUP BY보다는 WHERE 조건이 먼저 인덱스를 사용할 수 있게 실행계획이 수립된다
        
    ```
    WHERE 절의 조건이 검색을 위해 인덱스를 이용하고, GROUP BY가 같은 인덱스를 사용할 수 있는 쿼리라 하더라도 인덱스 루스 스캔을 사용하지 않을 수 있다. 즉 WHERE 조건에 의해 검색된 레코드 건수가 적으면 루스 인덱스 스캔을 사용하지 않아도 매우 빠르게 처리될 수 있기 때문이다. 루스 인덱스 스캔은 주로 대량의 레코드를 GROUP BY하는 경우 성능 향상 효과가 있을 수 있기 때문에 옵티마이저가 적절히 손익 분기점을 판단한다.
    ```

    * Using join buffer
        * 일반적으로 빠른 쿼리 실행을 위해 조인이 되는 칼럼은 인덱스를 생성한다
        * 실제로 조인에 필요한 인덱스는 조인되는 양쪽 테이블 칼럼 모두가 필요한 것이 아니라 조인에서 뒤에 읽는 테이블의 칼럼에만 필요하다
        * MySQl 옵티마이저도 조인되는 두 테이블에 있는 각 칼럼에서 인덱스를 조사하고, 인덱스가 없는 테이블이 있으면 그 테이블을 먼저 읽어서 조인을 실행한다
        
        ```
        RDBMS에서 조인을 처리하는 방법은 2~3가지 정도 되지만 MySQL에서는 중첩 루프 조인 방만 지원한다
        FROM 절에 아무리 테이블이 많아도 조인을 수행할 때 반드시 두 개의 테이블이 비교되는 방식으로 처리된다
        그리고 두 개의 테이블이 조인될 때 먼지 읽는 테이블을 드라이빙 테이블이라고 하며, 뒤에 읽히는 테입르을 드리븐 테이블이라고 한다
        
        예를 들어 조인이 다음과 같은 순서로 수행되는 쿼리가 있다고 하자
        A -> B -> C

        A 테이블과 B 테이블이 조인되는 과정에서 드라이빙 테이블은 A, 드리븐 테이블은 B다

        가끔은 드라이빙 테이블을 아우터 테이블, 드리분 테이블을 이너 테이블이라고 표현하기도 한다
        ```

        * 조인이 수행될 때 드리븐 테이블의 조인 칼럼에 적절한 인덱스가 없다면 드라이빙 테이블로부터 읽은 레코드 건수만큼
        매번 드리븐 테이블을 풀 테이블 스캔이나 인덱스 풀 스캔해야 한다
        * 이 때 드리븐 테이블의 비효율적인 검색을 보완하기 위해 MySQL 서버는 드라이빙 테이블에서 읽은 레코드를 임시 공간에 보관해두고 필요할 때 재사용할 수 있게 해준다
        * 읽은 레코드를 임시로 보관해두는 메모리 공간을 조인 버퍼라고 하며, 조인 버퍼가 사용되는 실행 계획의 Extra 칼럼에는 Using join buffer라는 메시지가 표시된다

        * 조인 버퍼는 joi_buffer_size라는 시스템 설정 변수에 최대 사용 가능한 버퍼 크기를 설정할 수 있다
        * 만약 조인되는 칼럼에 인덱스가 적절하게 준비돼있다면 조인 버퍼에 크게 신경쓰지 않아도 된다
        * 일반적으로 온라인 웹 서비스용 MySQl 서버라면 조인 버퍼는 1MB 정도로 충분하며, 더 크게 설정해야 할 필요는 없다
        * 아래와 같이 조인 조건이 없는 카테시안 조인을 수행하는 쿼리는 항상 조인 버퍼를 사용한다

        ```
        EXPLAIN
        SELECT *
        FROM dept_emp de, employees e
        WHERE de.from_date > '2005-01-01' AND e.emp_no < 10904;
        ```
    
    * Using sort_union, Using union, Using interact
        * 쿼리가 index_merge 접근 방식으로 실행되는 경우에는 2개 이상의 인덱스가 동시에 사용될 수 있다
        * 이때 실행 계획의 extra 칼럼에는 두 인덱스로부터 읽은 결과를 어떻게 병합했는지 조금 더 상세하게 설명하기 위해 다음 3개 중에서 하나의 메시지를 선택적으로 출력한다

        1. Using intersect
            * 각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우 각 처리 결과에서 교집합을 추출해내는 작업을 수행했음
        2. Using union
            * 각 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우 각 처리 결과에서 합집합을 추출해내는 작업을 수행했다는 의미함
        3. Using sort union
            * Using union과 같은 작업을 수행하지만 Using union으로 처리될 수 없는 경우
            (OR로 연결된 상대적으로 대량의 range 조건들)
            Using sort union은 프라이머리 키만 먼저 읽어서 병합한 후에야 비로소 레코드를 읽어서 반환할 수 있다

        * Using union과 Using sort union 모두 충분히 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우에 사용된다
        * Using union은 대체로 동등비교처럼 일치하는 레코드 건수가 많이 않을 때 사용되고, 각 조건이 크다 또는 작다와 같이 상대적으로 많은 레코드에 일치하는 조건이 사용되는 경우 Using sort union이 사용된다
        * 하지만 실제로는 레코드 건수에 거의 관계없이 각 where 조건에 사용된 비교 조건이 모두 동등 조건이면 Using union이 사용되며, 그렇지 않으면 Using sort union이 사용된다

    * Using temporary
        * MySQL은 쿼리를 처리하는 동안 결과를 담다 두기 위해 임시 테이블을 사용한다
        * 임시 테이블은 메모리상에 생성될 수도 있고 디스크 상에 생성될 수도 있다 
        * 임시 테이블을 사용하면 extra 칼럼에 Using temporary가 표시되는데 이걸로 메모리에 생성됐는지 디스크에 생성됐는지는 알 수 없다

        ```
        실행계획의 extra 칼럼의 Using temporary가 표시되지는 않지만, 실제 내부적으로는 임시 테이블을 사용할 때도 많다
        Extra 칼럼에 Using temporary가 표시되지 않는다고 해서 임시 테이블을 사용하지 않는다라고 판단하면 안된다
        대표적으로 메모리나 디스크에 임시 테이블을 생성하는 쿼리는 다음과 같다

        - FROM 절에 사용된 서브 쿼리는 무조건 임시 테이블을 생성한다
          이 테이블을 파생 테이블이라고는 하지만 결국 실체는 임시 테이블이다

        - COUNT(DISTINCT column)을 포함하는 쿼리도 인덱스를 사용할 수 없는 경우에는 임시 테이블이 만들어진다

        - UNION이나 UNION ALL이 사용된 쿼리도 항상 임시 테이블을 사용해서 결과를 병합한다

        - 인덱스를 사용하지 못하는 정렬작업 또한 임시 버퍼 공간을 사용하는데, 정렬해야 할 레코드가 많아지면 결국 디스크를 사용한다
          정렬에 사용되는 버퍼도 결국 실체는 임시 테이블과 같다 
          쿼리가 정렬을 수행할 때는 실행 계획의 extra 칼럼에 Using filesort라고 표시된다
        ```
    
    * Using where
        * MySQL은 내부적으로 크게 MySQL 엔진과 스토리지 엔진이라는 두 개의 레이어로 나눠서 볼 수 있다
        * 각 스토리지 엔진은 디스크나 메모리상에서 필요한 레코드를 읽거나 저장하는 역할을 한다
        * MySQL 엔진은 스토리지 엔진으로부터 받은 레코드를 가공 또는 연산하는 작업을 수행한다
        * MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에만 extra 칼럼에 using where 코멘트가 표시된다

        * 작업 범위 제한 조건은 각 스토리지 엔진 레벨에서 처리되지만 체크 조건은 MySQL 엔진 레이어에서 처리된다

        ```
        EXPLAIN
        SELECT * FROM employees WHERE emp_no BETWEEN 10001 AND 10100 AND gender='F';
        ```

        * 위 쿼리에서 작업 범위 제한 조건은 `emp_no BETWEEN 10001 AND 10100`이며 `gender='F'`은 체크 조건이다
        * 따라서 `gender='F'` 조건은 MySQL 엔진 레이어에서 처리된다

        ```
        위의 쿼리에 예지를 통해 인덱스 최적화를 조금 더 살펴보자
        위 처리 과정에서 최종적으로 쿼리에 일치하는 레코드는 37건 밖에 안되지만 스토리지 엔진은 100건의 레코드를 읽었다

        그런데 만약 employees 테이블에 (emp_no+gender)로 인덱스가 준비돼있다면 어떻게 될까?
        이때는 두 조건 모두 작업 범위 제한 조건으로 사용되며 필요한 37개의 레코드만 정확하게 읽을 수 있다
        일반적으로 extra 칼럼에 Using where가 표시되는 경우에는 MySQL 엔진에서 필터링 작업을 했다는 것을 의미한다
        그리고 그와 동시에 스토리지 엔진에 쓸모없는 일을 추가로 시켰다는 것을 의미한다
        이는 MySQL이 스토리지 엔진과 MySQl 엔진으로 이원화된 구조때문에 발생하는 문제점으로 볼 수 있다

        똑같이 MySQL 엔진과 스토리지 엔진의 이원화된 구조 탓에 발생하는 문제점을 더 살펴보자

        CREATE TABLE tb_likefilter (
            category int,
            name VARCHAR(30),
            INDEX ix_category_name(category, name)
        );

        SELECT * FROM tb_likefilter WHERE category=10 AND name like '%abc%;

        위 쿼리의 경우, category 칼럼과 name 칼럼이 인덱스로 생성돼 있다
        하지만 name LIKE '%abc%' 조건은 작업 범위 제한 조건으로 사용되지 못한다
        이처럼 작업 범위 제한 조건으로 사용되지 못하는 조건은 스토리지 엔진에서 인덱스를 통해 체크되는 것이 아니라 MySQL 엔진에서 처리된다
        즉, 스토리지 엔진에서는 category=10을 만족하는 모든 레코드를 읽어서 MySQL엔진으로 넘겨주고 MySQL엔진에서 name LIKE '%abc%' 조건 체크를 수행해서 일치하지 않는 레코드는 버리는 것이다

        예를 들어, category=10을 만족하는 레코드가 100건, 그중에서 name LIKE '%abc%' 조건을 만족하는 레코드가 10건이라면 MySQL 엔진은 10건의 레코드를 위해 그 10배의 작업을 스토리지 엔진에 요청한다
        상당히 불합리한 처리 방식이기도 하지만 MySQL 5.0이하에서는 피할 수 없는 문제였다
        InnoDB나 MyISAM과 같은 스토리지 엔진과 MySQL 엔진 외부에서 작동하는 NDB 클러스터는 네트워크 전송 부하까지 겹치기 때문에 성능에 미치는 영향이 더 큰 편이다

        MySQL 5.1의 InnoDB 플러그인 버전부터는 이원화된 구조의 불합리를 제거하기 위해 WHERE 절의 범위 제한 조건 뿐 아니라 체크 조건까지 모두 스토리지 엔진으로 전달된다
        스토리지 엔진에서는 그 조건에 정확히 일치하는 레코드만 읽고 MySQL엔진으로 전달하기 때문에 이런 비효율적인 부분이 사라진 것이다
        즉 MySQL 5.1부터는 위의 시나리오에서도 스토리지 엔진이 꼭 필요한 10건의 레코드만 읽게 되는 것이다

        MySQL에서 이러한 기능을 condition push down이라고 한다
        ```
    * Using where with pushed condition 
        * 해당 메시지는 condition push down이 적용됐음을 의미한다
        * MySQL 5.1부터는 condition push down이 InnoDB나 MyISAM 스토리지 엔진에도 도입되었지만 각 스토리지 엔진을 사용하는 테이블의 실행계획에는 Using where with pushed condition이 표시되지 않는다

        * 이 메시지는 NDB 클러스터 스토리지 엔진을 사용하는 테이블에서만 표시되는 메시지다
        * NDB 클러스터는 MySQL 엔진의 외부에서 작동하는 스토리지 엔진이라서 스토리지 엔진으로부터 읽은 레코드는 네트워크를 통해 MySQL엔진으로 전달된다

### EXPLAIN EXTENDED(Filtered 칼럼)

* MySQL 5.1 이상 버전이라 하더라도 스토리지 엔진에서 최종적으로 사용자에게 전달되는 레코드만 가져오는 것은 아니다
* 조인과 같은 여러 가지 이유로 여전히 각 스토리지 엔진에서 읽어 온 레코드를 MySQL 엔진에서 필터링하는데, 이 과정에서 버려지는 레코드가 발생할 수 밖에 없다

* MySQL 5.1부턴 필터링이 얼마나 효율적으로 실행됐는지를 사용자에게 알려주기 위해 실행계획에 Filtered라는 칼럼이 추가됐다
* Filtered 칼럼엔 MySQL 엔진에 의해 필터링되어 제거된 레코드는 제외하고 최종적으로 레코드가 얼마나 남았는지의 비율이 표시된다
* rows 칼럼의 값이 100건이고 filtered 칼럼의 값이 20%라면, 스토리지 엔진이 전체 100건의 레코드를 읽어서 MySQL 엔진에 전달됐는데, MySQL 엔진에 의해 필터링되고 20%만 남았다는 것을 의미한다
* 여기에 출력되는 filtered 칼럼의 정보 또한 실제 값이 아니라 단순히 통계 정보로부터 예측된 값일 뿐이다

### EXPLAIN EXTENDED(추가 옵티마이저 정보)

* EXPLAIN 명령의 EXTENDED 옵션은 숨은 기능이 하나 더 있다
* MySQL 엔진에서 쿼리의 실행 계획을 산출하기 위해 쿼리 문장을 분석해 파스 트리를 생성한다
* 또한 일부 최적화 작업도 이 파스 트리를 이용해 수행한다

* EXPLAIN EXTENDED 명령의 또 다른 기능은 분석된 파스 트리를 재조합해서 쿼리 문장과 비슷한 순서대로 나열해서 보여주는 것이다

> MySQL 5.7 이후부턴 EXPLAIN EXTENDED가 deprecated 되었으며, EXPLAIN만 사용해도 동일한 결과를 얻을 수 있다

* EXPLAIN EXNTEDED 명령을 실행하면 EXTENDED의 옵션이 없을 때와 같이 쿼리의 실행 계획만 화면에 출력된다
* 하지만 EXPLAIN EXNTEDED 명령을 실행해 실행 계획이 출력된 직후, SHOW WARNINGS 명령을 실행하면 옵티마이저가 분석해서 다시 재조합한 쿼리 문장을 다음과 같이 확인할 수 있다

### EXPLAIN PARTITIONS(Partition 칼럼)

* 단순히 EXPLAIN 명령으로는 파티션 테이블이 어떻게 사용됐는지 확인할 수 없다
* 하지만 EXPLAIN 명령 뒤에 PARTITIONS 옵션을 사용하면 쿼리를 실행하기 위해 테이블의 파티션 중에서 어떤 파티션을 사용했는지 등의 정보를 사용할 수 있다

```
CREATE TABLE tb_partition (
    reg_date DATE DEFAULT NULL,
    id INT DEFAULT NULL,
    name VARCHAR(50) DEFAULT NULL
) ENGINE=INNODB
partition BY range (YEAR(reg_date)) (
    partition p0 VALUES less than (2008) ENGINE=INNODB,
    partition p1 VALUES less than (2009) ENGINE=INNODB,
    partition p2 VALUES less than (2010) ENGINE=INNODB,
    partition p3 VALUES less than (2011) ENGINE=INNODB
);

EXPLAIN PARTITIONS
SELECT * FROM tb_partition
WHERE reg_date BETWEEN '2010-01-01' AND '2010-12-30';
```

> MySQL 5.7 이후부턴 EXPLAIN PARTITIONS가 deprecated 되었으며, EXPLAIN만 사용해도 동일한 결과를 얻을 수 있다

* tb_partition 테이블은 reg_date 칼럼의 값을 이용해 년도별로 구분된 파티션 4개를 가진다
* 2010년도 데이터를 읽으려할 땐 p3 파티션만 접근하면 된다
* 이처럼 파티션이 여러개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과저을 파티션 프루닝이라고 한다

## MySQl의 주요 처리 방식

* 앞으로 설명할 내용 중에서 풀 테이블 스캔을 제외한 나머지는 모두 MySQL엔진에서 처리된다
* MySQL엔진에서 처리하는 데 시간이 오래 걸리는 작업의 원리를 알아둔다면 쿼리를 튜닝하는데 상당히 많은 도움이 될 것이다

### 풀 테이블 스캔

* 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다
* 아래 조건을 만족할 때 옵티마이저가 풀 테이블 스캔을 선택한다
    * 테이블 레코드 건수가 너무 작어서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
    * where 절이나 on절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
    * 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
    * 반대로 max_seeks_for_key 변수를 특정 값(N)으로 설정하면 MySQL 옵티마이저는 인덱스의 기수성이나 선택도를 무시하고 최대 N건만 읽으면 된다고 판단하게 한다
    이 값을 작게 설정할수록 MySQL서버가 인덱스를 더 사용하도록 유도한다

* 일반적으로 테이블 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다
* 그래서 대부분의 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능이 있으며, 그 수를 조절할 수 있다
* 하지만 MySQL에는 풀 테이블 스캔을 실행할 때 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 변수는 없다
* 그래서 많은 사람은 MySQL이 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어오는 것으로 생각할 때가 많다

* 이것은 MyISAM 스토리지 엔진에는 맞는 이야기이지만 InnoDB에서는 틀린 말이다
* InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스래드에 의해 리드 어헤드 작업이 자동으로 시작된다
* 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다
* 즉, 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다
* 백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시킨다
* 이때 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해둔다
* 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리되는 것이다

* MySQL 5.1의 InnoDB 플러그인 버전부터는 언제 리드 어헤드를 시작할지 시스템 변수를 이용해 변경할 수 있다
* 그 시스템 변수의 이름이 innodb_read_ahead_threshold인데 일반적으로 디폴트 설정으로도 충분하지만 데이터웨어하우스용으로 MySQL을 사용한다면 이 욥션을 더 낮은 값으로 설정해서 더 자주 리드 어헤드가 시작되도록 유도하는 것도 좋은 방법이다

### ORDER BY 처리(Using filesort)

* 레코드 1~2건을 쿼리를 제외하면 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다
* 정렬을 처리할 땐 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법이 있다

| |장점|단점|
|-|---|---|
|인덱스를 이용|INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다|INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 많이 필요하다. 인덱스 개수가 늘어날수록 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시용 메모리가 많이 필요하다|
|Filesort 이용|인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다. 정렬해야 할 레코드 양이 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다|정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다|

* 아래와 같은 이유로 무든 정렬ㄹ을 인덱스를 이용하도록 튜닝하기란 거의 불가능하다
    * 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
    * GROUP BY의 결과 또는 DISTINCT와 같은 처리의 결과를 정렬해야 하는 경우
    * UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
    * 랜덤하게 결과 레코드를 가져와야 하는 경우(때로는 인덱스를 이용할 수 있도록 개선할 수 있다)

* MySQL 정렬 특성을 살펴보자

    * 소트 버퍼
        * 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 공간을 소트 버퍼라 한다
        * 소트 버퍼는 정렬이 필요할 때만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다
        * 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납한다
        
        * 정렬해야 할 레코드의 건수가 소트 버퍼만으로 할당된 공간보다 크다면 어떻게 처리될까?
        * 이때 MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다

        * 메모리의 소트버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 저장한다
        * 그 다음 레코드를 다시 정렬해서 반복적으로 디스크에 임시 저장한다
        * 이처럼 각 버퍼 크기 만큼씩 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다
        * 이 병합 작업을 멀티 머지라고 표현하면 수행된 멀티 머지 횟수는 sort_merged_passes라는 상태 변수에 누적된다

        * 정확한 원인은 모르지만 소트버퍼의 크기를 늘려도 벤치마크 결과에 큰 차이가 없다고 한다

        * 경험상, 소트 버퍼의 크기는 56kb에서 1mb 미만이 적절한다
        * 정렬을 위해 할당받는 소트 버퍼는 세션 메모리 영역에 해당한다
        * 즉 소트 버퍼는 클라이언트들이 공유할 수 없고 커넥션이 많으면 많을수록 정렬작업이 많으면 많을 수록 더 많은 메모리 공간이 사용된다
        * 소트 버퍼의 크기를 10~20mb와 같이 너무 크게 설정하면 메모리 대량의 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시에 실행되면 운영체제는 메모리 부족 현상을 격는다

        ```
        소트 버퍼를 크게 설정해셔 빠른 성능을 얻을 수는 없지만 디스크의 읽기와 쓰기 사용량은 줄일 수 있다
        그래서 MySQL 서버의 데이터가 만허나 디스크의 IO성능이 낮은 장비라면 소트 버퍼의 크기를 더 크게 설정하는 것이 도움이 될 수도 있다
        하지만 소트 버퍼를 너무 크게 설정하면 서버의 메모리가 부족해져서 MySQL 서버가 메모리 부족을 겪을 수도 있기 때문에 소트 버퍼의 크기는 적절히 설정하는 것이 좋다
        ```

    * 정렬 알고리즘
        * 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 2가지 정렬 알고리즘으로 나눌 수 있다

        * 싱글 패스 알고리즘
            * 소트 버퍼에 정렬 기준 칼럼과, SELECT 되는 칼럼을 전부 담아서 정렬을 수행하는 방법
        * 투 패스 알고리즘
            * 정렬대상과 프라이머리 키값만을 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 알고리즘
        
        * MySQL의 예전 정렬 방식인 투 패스 알고리즘은 테이블을 두 번 일거야 하기 때문에 상당히 불합리하다
        * 반면에 싱글 패스 알고리즘은 소트 버퍼 공간을 더 많이 요구한다

        * MySQL 5.x 버전에선 일반적으로 싱글 패스 알고리즘을 사용하지만 아래의 경우 투 패스 알고리즘을 사용한다
            * 레코드 크기가 max_length_for_sort_data 파라미터로 설정된 값보다 클 때
            * BLOB이나 TEXT 타입의 칼럼이 SELET 대상에 포함될 때
        
        * 얼핏 생각해보면 예전 방식이 빠를 것 같지만 항상 그런 것도 아니다
        * 정렬 대상 레코드 건수가 작을 땐 싱글 패스가 클 땐 투 패스 알고맂므이 더 효율적이다

        ```
        SELECT 쿼리에서 꼭 필요한 칼럼만 조회하지 않고 모든 칼럼을 가져오는 것은 정렬 버퍼를 몇 배에서 몇 십배까지 비효율적으로 사용하게 만들 가능성이 높다
        이는 꼭 정렬 버퍼에만 영향을 미치는 것만이 아닌 임시 테이블에도 영향을 미친다
        ```

    * 정렬의 처리 방식
        * 쿼리에 ORDER BY가 사용되면 반드시 다음 3가지 처리 방식 중 하나로 정렬이 처리된다
          (일반적으로 밑쪽에 있는 정렬 방법으로 갈수록 처리가 느려진다)

          |정렬 처리 방법|실행 계획의 extra 칼럼|
          |-----------|------------------|
          |인덱스 사용한 정렬|내용없음|
          |드라이빙 테이블만 정렬(조인이 없는 경우 포함)|using filesort|
          |조인 결과를 임시 테이블로 저장한 후, 임시 테이블에서 정렬|using temporary; using filesort| 
        
        * 먼저 옵티마이저는 정렬 처리를 위해 인덱스를 이용할수 있을지 검토한다
        * 만약 인덱스를 이용할 수 없다면 인덱스를 순서대로 읽어서 결과를 반환한다
        * 이용할 수 없다면 where조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리한다
        * 이때 MySQL 옵티마이저는 정렬대상 레코드를 최소화하기 위해 다음 두 가지 방법 중 하나를 선택한다
            * 드라이빙 테이블만 정렬한 다음 조인을 수행
            * 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행
        * 일반적으로 조인이 되면서 레코드 건수가 거의 배수로 불어나기 때문에 가능하면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 것이 효율적이다 

        * 인덱스를 이용한 정렬
            * ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우, 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다
            * 또한 WHERE 절에 첫번째 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다
            * B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스에선 인덱스를 이용한 정렬을 사용할 수 없다 
            * 여러 테이블이 조인되는 경우는 네스티드 루프 방식의 조인에서만 이 방식을 사용할 수 있다

            ```
            ORDER BY 절을 넣지 않아도 자동으로 정렬된다고 해서 ORDER BY 절 자체를 쿼리에서 완전히 빼고 쿼리를 작성하기도 한다
            하지만 MySQL 서버는 정렬을 인덱스로 처리할 수 있다면 부가적으로 불필요한 정렬작업을 수행하지 ㅏㅇㄴㅎ는다
            그래서 인덱스로 정렬이 처리될 때는 ORDER BY가 쿼리에 명시된다고 해서 작업량이 더 늘지는 않는다
            또한 어떤 이유때문에 쿼리의 실행 계획이 조금 변경된다면 ORDER BY가 명시되지 않은 쿼리는 결과가 기대했던 순서대로 가져오지 못해서 어플리케이션의 버그로 이어질 수 있다
            ```

        * 드라이빙 테이블만 정렬
            * 일반적으로 조인이 수행되면 결과 레코드의 건수가 몇 배로 불어난다
            * 그래서 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 차선책이다 
            * 이 방법은 조인에서 첫 번째 읽히는 테이블의 칼럼만으로 ORDER BY 절이 작성돼야 한다

        * 임시 테이블을 이용한 정렬
            * 쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 SELECT 해서 정렬하는 경우라면 임시 테이블이 필요하지 않다
            * 하지만 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다
            * 위에서 살펴본 드라이빙 테이블만 정렬은 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시 테이블을 사용하지 않는다
            * 하지만 그 밖의 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다
            
            * 이 방법은 정렬의 3가지 방법 중 정렬해야 할 레코드 건수가 가장 많아 가장 느리다
        
        * 정렬 방식의 성능 비교
            * WhERE 조건이 아무리 인덱스를 잘 타더라도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생한다

            * 쿼리에서 인덱스를 잘 사용하지 못하는 정렬이나 그룹핑 작업이 왜 느리게 작동할 수 밖에 없는지 한번 살펴보자
            * 이를 위해 쿼리가 처리되는 방법을 스트리밍 처리와 버퍼링 처리라는 2가지 방식을 구분해보자

            * 스트리밍 방식
                * 서버 쪽에서 처리해야 할 데이터가 얼마나 될지에 관계없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식을 말한다
                * 이 방식으로 쿼리를 처리할 경우 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 전달받을 것이다
                * 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있다
                * 웹 서비스와 같은 OLTP 환경에서는 뭐리의 요청에서부터 첫 번째 레코드를 전달받게 되기까지의 응답 시간이 중요하다
                * 스트리밍 방식으로 처리되는 쿼리는 쿼리가 얼마나 많은 레코드를 조회하느냐에 따라 상관없이 빠른 응답 시간을 보장해준다
                
                ```
                스트리밍 처리는 어떤 클라이언트 도구나 API를 사용하느냐에 따라 그 방식에 차이가 있을 수 있다
                대표적으로 JDBC 라이브러리를 이용해 SELECT * FROM tb_bigtable와 같은 쿼리를 실행하면 MySQL 서버는 레코드를 읽자마자 클라이언트로 그 결과를 전달할 것이다
                하지만 JDBC는 MySQL 서버로부터 받는 레코드를 일단 자체적인 버퍼에 모두 담아둔다
                그리고 마지막 레코드가 전달될 때까지 기다렸다가 모든 결과를 받으면 그때서야 클라이언트의 애플리케이션에 반환한다

                JDBC 라이브러리가 자체적으로 레코드를 버퍼링하는 이유는 이 방식이 전체 처리량에서 뛰어나기 때문이다
                이 방식은 JDBC 라이브러리와 MySQL 서버가 대화형으로 데이터를 주고받는 것이 아니라 MySQL 서버는 데이터의 크기에 관계없이 무조건 보내고, JDBC MySQL 서버로부터 전송되는 데이터를 받아서 저장만하므로 불필요한 네트워크 요청이 최소화되기 때문에 전체 처리량이 뛰어난 것이다

                하지만 JDBC의 버퍼링 처리 방식은 기본 작동 방식이며, 아주 대량의 데이터를 가져와야 할 때는 MySQL 서버와 JDBC 간의 전송 방식을 스트리밍 방식으로 변경할 수 있다
                ```
            
            * 버퍼링 방식
                * ORDER BY나 GROUP BY 같은 처리는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 한다

            * 위에 언급된 3가지 정렬 방식 중 인덱스로 정렬할 때만 스트리밍 방식으로 처리되고 나머지는 버퍼링 방식으로 처리된다

            * 어느 테이블이 먼저 드라이빙 되어 조인되는지도 중요하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 만든다
            * 가능하다면 인덱스를 사용한 정렬로 유도하고 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법이라고 할 수 있다

        * 정렬 관련 상태 변수
            * 정렬과 관련해서 지금까지 몇 건의 레코드나 정렬 처리를 했는지, 멀티 머지는 몇번 했는지 등을 다음과 같이 확인할 수 있다

            ```
            SHOW SESSION STATUS LIKE 'Sort%';
            ```

            * sort_merge_passes: 멀티 머지 처리 횟수
            * sort_range: 인덱스 레인트 스캔을 통해 검색된 결과
            * sort_scan: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
            * sort_rows: 지금까지 정렬한 전체 레코드 건수

### GROUP BY 처리

* GROUP BY에 사용된 조건ㅇㄴ 인덱스를 사용해서 처리할 수 없으므로 HAVING 절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없다

* GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눠 볼 수 있다
* 인덱스를 이용할 땐 인덱스를 차례대로 이용하는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔으로 나뉜다
* 인덱스를 이용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용한다

    * 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
        * 조인의 드라이빙 테이블에 속한 칼럼만 이용해 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스 그룹을 차례대로 읽어 그룹핑 작업을 수행하고 그 결과로 조인을 처리한다
        * 인덱스를 사용해서 처리한다 하더라도 그룹 함수 등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다
        * 이런 그룹핑 방식을 사용하는 쿼리의 실행 계획에서는 Using index for group by나 Using temporary; Using filesort가 표시된지 않는다

    * 루스 인덱스 스캔을 이용하는 GROUP BY
        * 인덱스의 레코드를 건너뛰면서 필요한 부분만 가져오는 것을 의미한다
        
        ```
        EXPLAIN
        SELECt emp_no
        FROM salaries
        WHERE from_date='1995-03-01'
        GROUP BY emp_no;
        ```

        * salaries 테이블의 인덱스는 (emp_no + from_date)로 생성돼 있다
        * 따라서 쿼리의 WHERE 조건은 인덱스를 사용할 수 없다
        * 하지만 실행 계획의 extra 칼럼을 보면 GROUP BY 처리까지 인덱스를 사용했음을 알 수 있다
            (Using where; Using index for group-by)
        
        * MySQL 서버는 위 쿼리를 다음과 같이 처리한다
            1. (emp_no+from_date) 인덱스를 차례대로 스캔하면서, emp_no의 첫 번째 유일한 값을 찾아낸다
            2. (emp_no+from_date) 인덱스에서 emp_no가 10001인 것 중에서 from_date 값이 1985-03-01인 레코드만 가져온다
            이 검색 방법은 1번 단계에서 알아낸 10001 값과 쿼리의 WHERE절에 사용된 from_date=1985-03-01 조건을 합쳐서 emp_no=10001 AND from_date=1985-03-01 조건으로 (emp_no+from_date) 인덱스를 검색하는 것과 흡사하다
            3. (emp_no+from_date) 인덱스에서 emp_no의 그 다음 유니크한 값을 가져온다
            4. 3번 단계에서 결과가 더 없으면 처리를 종료하고, 결과가 있다면 2번 과정으로 돌아가서 반복 수행한다
        
        * 인덱스 레인지 스캔에서는 유니크한 값의 수가 많을수록 성능이 향상되는 반면, 루스 인덱스 스캔에서는 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다
        * 즉 루스 인덱스 스캔은 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만들어낸다
        * 루스 인덱스로 처리되는 쿼리에서는 별도의 임시 테이블이 필요없다

        * 루스 인덱스 스캔이 사용될 수 있을지 없을지 판단하는 건 어렵다
        * 아래 쿼리들은 루스 인덱스 스캔을 사용할 수 있다

        ```
        SELECT col1, col2, FROM tb_test GROUP BY col1, col2;
        SELECT DISTINCT col1, col2 FROM tb_test;
        SElECT col1, MIN(col2) FROM tb_test GROUP BY col1;
        SELECT col1, col2 FROM tb_test WHERE col1 < const GROUP BY col1, col2;
        SELECT MAX(col3), MIN(col3), col1, col2 FROM tb_test WHERE col2 > const GROUP BY col1, col2;
        SELECT col2 FROM tb_test WHERE col1 < const GROUP BY col1, col2;
        SELECT col1, col2 FROM tb_test WHERE col3 = const GROUP BY col1, col2;
        ```

        * 아래 쿼리들은 루스 인덱스 스캔을 사용할 수 없다
        ```
        // MIN과 MAX이외의 집합함수가 사용됨
        SElECT col1, SUM(col2) FROM tb_test GROUP BY col1;

        // GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않기 때문임
        SELECT col1, col2 FROM tb_test GROUP BY col2, col3;

        // SELECT 절의 칼럼이 GROUP BY와 일치하지 않기 때문임
        SELECT col1, col3 FROM tb_test GROUP BY col1, col2;
        ```

        ```
        일반적으로 B-tree 인덱스는 인덱스를 구성하는 칼럼이 왼쪽부터 일치하는 형태로 사용될 때만 사용할 수 있다
        하지만 루스 인덱스 스캔은 인덱스의 첫번째 칼럼이 WHERE 조건이나 GROUP BY에 사용되지 않아도 B-Tree 인덱스를 사용할 수 있는 방식이기도 하다
        ```

    * 임시 테이블을 사용하는 GROUP BY
        * GROUP BY의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다

### DISTINCT 처리

* DISTINCT는 집합 함수와 같이 사용되는 경우와 그렇지 않은 경우로 나눠서 생각해야 한다
* 이렇게 구분하는 이유는 DISTINCT 키워드가 영향을 미치는 범위가 달라지기 때문이다
* 집합 함수와 같이 DISTINCT가 사용되는 쿼리에서 DISTINCt 처리가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요하다
  (하지만 실행 계획엔 using temporary가 표시되지 않는다)
