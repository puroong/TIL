# 확장성 있는 웹 아키텍처와 분산 시스템


https://d2.naver.com/helloworld/206816
위 글을 읽고 정리한 문서입니다

## 웹 분산 시스템 설계 시의 고려사항

* 가용성
    - 서비스가 중단되지 않고 성능을 유지해야함
* 성능
    - 낮은 latency, 빠른 응답 속도
* 신뢰성
    - 똑같은 요청엔 항상 같은 응답을 줘야함
* 확장성
    - 얼마나 더 많은 부하를 처리할 수 있도록 처리량을 증가시키기 위해 필요한 노력
* 관리성
    - 문제 발생 시 분석하기 용이하고 업데이트, 수정 등이 쉬워야함
* 비용
    - 시스템을 운영하는데 드는 비용(시간, 돈 등)

결정을 내릴 때 트레이트 오프 생각하면서 설계해야함
ex. scale-out하면 성능과 가용성은 좋아지겠지만 비용이 추가되고 관리하긴 어려움

## 기초

### 이미지 호스팅 어플리케이션

#### 서론
* 목표
    - 효율적인 비용과 고가용성을 만족하고 적은 레이턴시를 가지는 아키텍처를 구축하자
* 기능 
    - 이미지 업로드
    - 이미지 조회
* 고려할 부분
    - 저장될 이미지 개수에 제한 없음 -> 저장공간의 확장성 고려해야함
    - 이미지 보기나 다운로드 요청 시 응답 시간이 빨라야함
    - 이미지 업로드 난 후, 해당 이미지는 항상 시스템에 저장돼있어야함 (데이터에 대한 신뢰성)
    - 시스템을 운용하기 쉬워야 함 (관리성)
    - 이미지 호스팅 자체의 이익율이 높지 않으므로 시스템 비용은 효율적으로 운용돼야함

![architecture1](https://d2.naver.com/content/images/2015/06/helloworld-206816-1.jpg)

#### 서비스들

확장성 있는 시스템 설계 시 각각의 명확한 인터페이스 기반으로 기능별로 나눠 생각하는 것이 좋음 (SOA: Service Oriented Architecture)

SOA는 기능별로 서비스를 구성하며 각각의 서비스는 다른 서비스와 상호작용 하기위해 다른 서비스가 공개하는 API 형태인 추상화된 인터페이스를 사용함
    
* 장점
    - 문제를 분리시키는데 좋음
    - 각 기능을 독립적으로 확장시키기 쉬움
    - 각각의 문제를 독립적으로 해결할 수 있음
        ex. 쓰기와 조회를 분리하는 경우 같은 서비스 영역에서 쓰기와 조회를 걱정할 필요 없음

![architecture2](https://d2.naver.com/content/images/2015/06/helloworld-206816-2.png)

#### 이중화

장애가 발생해도 서비스를 계속 제공할 수 있도록 이중화를 함

어떤 인스턴스에서 장애 발생 시 문제가 없는 다른 인스턴스만 동작하도록 할 수 있음
    - 자동 (로드밸런서)
    - 관리자가 직접 설정

![architecture3](https://d2.naver.com/content/images/2015/06/helloworld-206816-3.png)

#### 파티션

서버에 데이터가 많아서 확장이 필요할 때
    - 수직적 확장
    - 수평적 확장

##### 수직적 확장

서버 자원 업그레이드 통해 확장하는 것

##### 수평적 확장

노드를 더 추가를 통해 확장하는 것

일반적으로 서비스나 파티션을 샤드 단위로 분할함

이떄 파티션은 기능별 논리 집합으로 분리 가능함
    - 무료 사용자 vs 유료 사용자
    - 지역별 사용자
    - 기타 등등

데이터를 여러 서버에 저장할 때 해당 데이터가 어떤 서버에 저장돼있는지 찾을 수 있어야함
    - ex. 이미지의 경우 이미지 이름을 바탕으로 저장된 서버를 찾을 수 있는 방법이 필요함
        - 이미지 id를 통해 찾는 방법이 있음
        - 서버 위치를 가리키는 값을 해싱하여 이미지 이름으로 사용하는 방법이 있음
        - **[TODO]예시 및 자료 더 찾아보면 좋을 듯**

###### 고려사항
    - 데이터 로컬리티
        * 조회하려는 데이터가 가까이 없는 경우 데이터를 읻기 위해 네트워크 비용이 많이 들어갈 수 있음
    - 비정합성(inconsistency)
        * 쓰기 요청 전후로 발생된 읽기 요청 값이 다를 수 있음 -> 경합 조건(race condition)
    - ![더 읽어볼 것](http://katemats.com/distributed-systems-basics-handling-failure-fault-tolerance-and-monitoring/)

## 데이터 액세스 확장

![simple_architecture](https://d2.naver.com/content/images/2015/06/helloworld-206816-5.png)

* 어플리케이션 서버에 대한 데이터 액세스 확장
    - 대부분 확장성을 고려하여 설계된 것들은 최소 단위, shared-nothing 아키텍처로 설계됨
* 데이터베이스에 대한 데이터 액세스 확장

### 데이터베이스에 대한 데이터 액세스 확장

저장해야할 데이터 용량이 아주 큰 경우

![bigdata_databases](https://d2.naver.com/content/images/2015/06/helloworld-206816-7.png)

대용량의 데이터를 메모리에 올리는덴 비용이 매우 비싸므로 적절한 처리가 필요함
    - 디스크 I/O가 성능에 매우 큰 영향을 끼침
    - 파일처리를 배우는 이유

대표적인 처리방법 4가지
    - 캐시
    - 프락시
    - 인덱스
    - 로드 밸런서

#### 캐시

캐시는 최근에 요청받은 데이터는 다시 요청받을 확률이 높다는 지역성의 원리에 기반한 방법임

latency를 줄이기 위해 보통 프론트엔드와 가까운 곳에 위치하는 경우가 많음