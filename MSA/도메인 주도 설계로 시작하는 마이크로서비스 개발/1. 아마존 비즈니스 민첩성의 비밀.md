# 1. 아마존 비즈니스 민첩성의 비밀

**스케일 업 vs 스케일 아웃**
* 스케일 업
    * 기존 시스템 자체의 무리적 용량을 증가시켜 성능을 높이는 방법

* 스케일 아웃
    * 기존 시스템과 용량이 같은 다수의 장비를 병행 추가하여 가용성을 높이는 방법

**클라우드 프렌들리와 클라우드 네이티브**
* 클라우드 프렌들리
    * 클라우드에 한 덩이러로 올라갈 수 있는 어플리케이션을 클라우드 프렌들리 어플리케이션이라고 한다

* 클라우드 네이트브
    * 독립적으로 분리되어 배포될 수 있는 조각으로 구성된 어플리케이션을 클라우드 인프라에 가장 어울리고 효과적이라는 의미로 클라우드 네이티브 어플리케이션이라고 부른다

## 마이크로서비스란?

### 모노리스 vs 마이크로서비스

* 모노리스
    * 하나의 단위로 개발되는 일체식 어플리케이션
    * 일반적으로 3티어로 구성됨
        * 사용자 인터페이스
        * 데이터베이스
        * 서버 어플리케이션
    * 서버 어플리케이션이 일체식
        * 아무리 작은 변화라도 전체를 빌드해서 배포해야 함
        * 확장이 필요한 경우 전체 어플리케이션을 동시에 확장해야 함
    * 데이터베이스가 통합되어 있어 처리량에 한계가 있음

### SOA와 마이크로서비스

* 넓게 보면 여러 개의 응집된 비즈니스 서비스의 집합으로 시스템을 개발한다는 점에서 SOA와 MSA는 개념적으로는 큰 차이가 없다
* 다만 SOA는 구체적이지 않고 이론적이며, 실제 비즈니스 성공 사례가 별로 없었고 MSA는 클라우드 인프라 기술의 발전과 접목되어 여러 비즈니스 성공 사례가 있다

* 마틴 파울러의 MSA 정의
    ```
    마이크로서비스는 여러 개의 작은 서비스 집합으로 개발하는 접근 방식이다
    각 서비스는 개별 프로세스에서 실행되고, HTTP 자원 API 같은 가벼운 수단을 사용해서 통신한다
    또한 서비스는 비즈니스 기능 단위로 구성되고, 자동화된 배포 방식을 이용하여 독립적으로 배포된다
    또한 서비스에 대한 중앙 집중적인 관리는 최소화하고, 각 서비스는 서로 다른 언어와 데이터, 저장 기술을 사용할 수 있다
    ```
    * 각 서비스와 저장소는 다른 서비스/저장소와 격리돼 있으며, API를 통해서 느슨하게 연계된다
    * 따라서 독립적으로 확장 가능하고 하나의 서비스만 독립적으로 배포 가능하다
    * 또한 다른 서비스와 연계된 API에게 영향을 주지 않는다면 내부의 언어나 저장소는 자율적으로 선택할 수 있다
        * 이처럼 특정 서비스를 구축하는데 사용되는 언어나 저장소를 자율적으로 선택할 수 있는 방식을 가리켜 폴리글랏이라고 한다

* CBD/SOA의 접근법에서는 어플리케이션은 모듈 별로 분리했으나 데이터 저장소까지 분리하진 못했다
  (여러 어플리케이션이 하나의 저장소를 통합해서 사용했다)
* 따라서 데이터의 강한 결합으로 어플리케이션을 독립적으로 사용하기 어려웠다

* MSA에서는 SOA에는 없는 두 가지 개념으로 모듈화 방식을 강화헀다 (SOA와 가장 큰 차이점)
    1. 서비스 별 저장소를 분리해서 다른 서비스가 저장소를 직접 호출하지 못하도록 캡슐화했다
       오직 API를 통해서 접근할 수 있다
    2. REST API 같은 가벼운 개방형 표준을 사용해 각 서비스가 느슨하게 연계되고 누구나 쉽게 사용될 수 있다

## 마이크로서비스를 위한 조건

### 조직의 변호(업무 기능 중심 팀)

* 콘웨이 법칙
    * 시스템을 개발할 때 항상 시스템의 모양이 팀의 의사소통 구조를 반영한다

* 모노리스 시스템을 개발하고 있다면 UI팀, 서버팀, DB팀으로 나누어 일할 수 있다
    * but, 팀 간의 의사소통이 어렵다

* 마이크로서비스를 만드는 팀은 업무 기능 중심이어야 한다
    * 업무 기능을 중심으로 기술이 다양한 사람들이 하나의 팀이 되어 서비스를 만드는 것
    * 한 팀에 기획자, 디자이너, 프론트엔드 개발자, 백엔드 개발자, 설계자, 테스터 등으로 구성된다
    * 다른 마이크로서비스 팀과는 협력할 일이 적다

### 관리체계의 변화(자율적인 분권 거버넌스, 폴리글랏)

* 마이크로서비스를 만드는 조직은 중앙의 강력한 표준이나 절차 준수를 강요하지 않는다
* 각 팀은 빠르게 서비스를 만드는 것을 최우선 목적으로 두고 스스로 효율적인 방법론과 도구, 기술을 찾아 적용한다

### 개발 생명주기의 변화(프로젝트가 아니라 제품 중심으로)

* 기존에는 대부분의 어플리케이션 개발 모델이 프로젝트 단위였다
* 장기간의 프로젝트를 통해 개발을 완료하고 나면 이를 운영 조직으로 넘기는 식으로 진행됐다

* 또한 초기에 모든 일정을 계획했다
* **따라서 프로젝트 기간 중에 발생한 변경이나 새로운 아이디어를 포용하지 못했다**

* 마이크로서비스 개발은 트렌트 변화에 유연하게 대처해야 하고 개발 뿐만 아니라 운영을 포함한 소프트웨어의 전체적인 생명주기를 책임져야 한다
* 따라서 소프트웨어를 비즈니스를 제공하는 제품으로 바라보고, 우선 개발한 뒤에 반응을 보고 개선하는 방식으로 소프트웨어를 개발한다

* 폭포수 방식이 아닌 애자일 방식을 채용하는 것이다

* 이 같은 방식은 2~3주 단위의 스프린트를 통해 소프트웨어를 개발 및 배포해서 바로 피드백을 받아 소프트웨어에 반영할 수 있게 한다
* 따라서 소프트웨어를 고객의 고정된 요건을 받아 기능이 만족되면 제공되는 개념으로 보지 않고 요건의 변화에 따라 지속적으로 개선된고 발전시킬 제품으로 바라본다

* 즉, 마이크로서비스는 계속 피드백을 받아 지속적으로 변화, 개선되고 향상되는 존재다

### 개발환경의 변화(인프라 자동화)

* 마이크로서비스는 여러 서비스로 구성되기 떄문에 빠르게 배포하기 위한 방법이 필요하다

* 가장 좋은 방법은 자동화다
* 개발지원 환경을 자동화하는 데는 소스코드를 빌드하는 도구와 빌드와 동시에 테스트하는 도구, 가상화된 인프라에 배포하는 도구가 모두 필요하다
* 단기간에 제품을 빨리 개발하고 피드백을 받기 위해선 이러한 개발지원 환경의 자동화가 필수다
* 이 같은 환경은 개발과 운영을 동시에 수행하는 데브옵스를 궁극적으로 가능하게 하므로 데브옵스 개발 환경이라 속칭하기도 한다

* 빌드/배포 파이프라인
    * 컴파일, 유닛 테스트 -> 기능 테스트 -> 통합 테스트 -> 인수 테스트 -> 성능 테스트 -> 배포
    * 소스코드 빌드 -> 개발환경 배포 -> 스테이징 환경 배포 -> 운영 환경 배포로 구성된다
    
* 이러한 빌드/배포 파이프라인 프로세스는 도구를 통해 자동화해야 한다
* 최근에는 이를 효율적으로 관리하기 위해 인프라 구성과 자동화를 마치 소프트웨어처럼 코드를 이용해 처리하는 방식인 Infrastructure as Code가 각광받고 있다
* 인프라 구성부터 어플리케이션 빌드, 배포를 정의하는 것을 의미하는데, 이렇게 되면 수많은 하드웨어 리소스 설정을 동일하게 통제할 수 있으며, 사오항에 따른 검증되고 적절한 설정을 쉽게 복제하고 누구한테나 공유할 수 있게 돼서 인프라를 매우 효율적으로 관리할 수 있다

### 저장소의 변화(통합 저장소가 아닌)

* 모노리스 시스템은 단일 통합 데이터베이스를 사용한다
    * 과거 스토리지 가격 및 네트워크 속도에 따른 데이터 안정성과 효율성을 추구한 결과다
    * 그러나 지금은 스토리지 가격이 저렴하고 네트워크 대역폭이 매우 커졌다
    * 단일 통합 데이터베이스에 모든 데이터를 저장할 필요가 없다

* 마이크로서비스는 폴리글랏 저장소 접근법을 선택하며, 서비스 별로 데이터베이스를 갖도록 설계한다
* 즉, 각 저장소가 서비스 별로 분산돼 있어야 하며, 다른 서비스의 저장소를 직접 호출할 수가 업속 API를 통해서만 접근해야 한다는 의미다

* 이러한 구조에서는 비즈니스 처리를 위해 일부 데이터의 복제와 중복 허용이 필요하다
* 여기서 반드시 등장하는 문제가 있는데, 각 서비스의 저장소에 담긴 데이터의 비즈니스 정합성을 맞춰야 하는 데이터 일관성 문제다

* 데이터 일관성 처리를 위해서는 보통 2단계 커밋 같은 분산 트랜잭션 기법을 사용하는데, 각각 다른 서비스를 하나의 트랜잭션으로 묶다 보면 각 서비스의 독립성도 침해되고 NoSQL 저장소처럼 2단계 커밋을 지원하지 않는 경우도 있다
* 따라서 마이크로서비스는 데이터 일관성 문제를 해결하기 위해 비동기 이벤트 처리를 통한 협업을 강조한다

* 이를 가리켜 결과적 일관성이라는 개념으로 표현하기도 하는데, 간단히 말해 두 서비스의 데이터가 일시적으로 불일치하는 시점에 있고 일관성이 없는 상태지만 결국에는 두 데이터가 같아진다는 개념이다
* 즉 별도의 로컬 트랜잭션을 각각 수행하고 일관성이 달라진 부분은 체크해서 보상 트랜잭션으로 일관성을 맞추는 개념이다

* 주문 서비스와 배송 서비스로 구분된 마이크로서비스 시스템이 있다
* 주문이 발생하면 반드시 배송 처리가 돼야 하는 비즈니스가 있다고 생각해보자
* 두 업무를 2단계 커밋으로 처리할 수 있다면 배송이 실패한 경우 롤백 처리할 수 있지만, 주문/배송 하나라도 데이터 저장소가 2단계 커밋을 지원하지 않는다면 불가능하다
* 또한 분산 트랜잭션으로 묶는다면 두 서비스가 강하게 결합되어서 서비스를 분리한 효과를 누리기 어려울 것이다
* 마이크로서비스가 추구하는 다른 바업ㅂ은 각 트랜잭션을 분리하고 큐 메커니즘을 이용해 보상 트랜잭션을 활용하는 방법이다

* 과정
    1. 주문 서비스가 주문 처리 트랜잭션을 수행한다
        a. 동시에 주문 이벤트를 발행한다
        b. 주문 이벤트가 메시지 큐로 전송된다
        c. 배송 서비스가 주문 이벤트를 인식한다
    2. 배송 서비스가 주문 처리에 맞는 배송 처리 트랜잭션을 수행한다 (비즈니스 일관성 만족)
    3. 배송 처리 트랜잭션 중 오류로 트랜잭션을 실패한다
        a. 배송 처리 실패 이벤트를 발행한다
        b. 배송 처리 실패 이벤트가 메시지 큐로 전송된다
        c. 주문 서비스가 배송 처리 실패 이벤트를 인식한다
    4. 주문 서비스는 주문 취소(트랜잭션)를 수행한다 (비즈니스 일관성 만족)

### 위기 대응 빙식의 변화(실패를 고려한 설계)

* 시스템은 언제든 실패할 수 있으며, 실패해서 더는 진행할 수 없을 때도 자연스럽게 대응할 수 있도록 설계해야 한다
    * 내결함성

* 예전의 시스템 아키텍처는 무결함이나 실패 무결성을 추구했다
* 하지만 어떤 시스템도 실패가 있을 수 밖에 없다
* 따라서 실패에 빠르게 대응할 수 있는 시스템을 만드는 편이 더 쉽고 효율적이다

* 이를 위해 다양한 실패에 대비해서 완벽히 테스트할 수 있는 환경을 마련해야 하고, 시스템의 실패를 감지하고 대응하기 위해 모니터링 체계도 갖춰야 한다
* 이러한 예로 서킷 브레이커 패턴을 들 수 있는데, 이 패턴은 회로 차단기처럼 각 서비스를 모니터링하고 있다가 한 서비스가 다운되거나 실패하면 이를 호출하는 서비스의 연계를 차단하고 적절하게 대응하는 것을 말한다
* 이러한 설계는 서비스가 긴급 정애 상황에 빠르고 유연하고 탄력적으로 대응할 수 있게 한다

## 정리

* MSA의 성공을 위해서는 아키텍처 및 개인의 역량에만 집중할 것이 아니라 조직문화, 일하는 절차 등을 고려해야 한다