# 1. Strategy Pattern

## 개요

아래와 같은 상속 구조가 있다고 하자

모든 오리는 울 수 있고, 수영할 수 있다

![](/assets/strategy-pattern-initial-structure.png)

만약 오리가 날 수 있어야한다는 요구사항이 들어오면 어떻게 해야할까?

먼저 Duck에 fly라는 메소드를 추가하는 방법을 생각해볼 수 있다

하지만 모든 오리가 날 수 있어야 하는건 아닐 것이다

예를 들어 장난감 오리는 날 수 없다

![](/assets/strategy-pattern-add-fly.png)

위 예시에서 볼 수 있듯이 서브클래스들의 공통 기능이 아닌 경우, 상속으로 구현하기 어렵다

## 인터페이스

비행, 울기와 같은 기능을 인터페이스로 나누면 서브클래스에서 필요한 기능만 선택하여 구현할 수 있다

하지만 인터페이스는 코드 재사용성에 영향을 준다

비행 기능이 있는 서브 클래스가 많을수록 비행 인터페이스를 구현해줘야 한다

이러한 점이 유지보수 측면에서 오히려 안좋을 수 있다

## 개선 방법

상속은 변화하는 요구사항을 충족시키는데 어려움이 있고, 인테페이스 또한 유지보수 측면에서 좋지 않다는 점을 알 수 있었다

> 변하지 않는 것과 변하는 것을 구분하자

Duck이라는 속성은 변하지 않는다

하지만 비행, 울기와 같이 각 오리 별로 할 수 있는 행동은 변할 수 있다

따라서 이러한 행동을 별도의 클래스로 분리하자

> 구현보단 인테페이스에 맞춰서 설계하자

비행을 할 수 있는 오리와 할 수 없는 오리가 있다

이 둘을 FlyingBehavior라는 인터페이스로 추상화하고 비행을 할 수 있는지 여부는 런타임에서 결정될 수 있도록 하자

![](/assets/strategy-pattern-segregate-behavior.png)

위와 같이 각 행동을 인스턴스 변수로 가지고 있으므로 적절한 구현을 변수에 저장하여 요구사항을 충족 시킬 수 있다

> 상속보단 합셩을 우선시하자

위 예시처럼 합성으로 시스템을 유연하게 만들 수 있다

**Strategy Pattern은 행위를 클래스로 캡슐화하여 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴이다**

